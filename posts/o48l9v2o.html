<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>这是一个神奇的主题</title>
    <!-- <link rel="stylesheet" href="//cdn.yesuanzao.cn/blog/chicken.css"> -->
    <link rel="stylesheet" href="//cdn.yesuanzao.cn/blog/atom-one-dark.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css">
    <!-- 本地静态文件测试 -->
    <link rel="stylesheet" href="/css/chicken.css">
<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <header>
    <div class="container">
        <div class="site-title"><a href="/">小鸡米花的知识库</a></div>
        <nav>
            <a class="nav-item " href="/">主页</a>
            <a class="nav-item " href="/archives">时光轴</a>
        </nav>
    </div>
</header>
    <div id="write">
    <div class="container">
        <div class="post-info">
            <ul class="tag-list">
                
                    <a class="tag-list-item" href="/tags/Node-js/">Node.js</a>
                
            </ul>
        </div>
        <div class="post-content"><h1 id="大前端笔记之20-⚙️-Node-js"><a href="#大前端笔记之20-⚙️-Node-js" class="headerlink" title="大前端笔记之20 ⚙️ Node.js"></a>大前端笔记之20 ⚙️ Node.js</h1><p>Node.js 是一个类似于 Chrome V8 引擎的 JavaScript 运行环境，它使得 JavaScript 可以工作在服务器端，实现操作文件、构建网络服务等功能。</p>
<p>首先在<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">官网</a>选择对应的版本下载安装。安装完成后在终端输入<code>node -v</code>命令，如果安装成功，则会显示当前 Node.js 的版本号。注意，Node.js 安装版会自动配置环境变量，如果没有，则需要自行配置。</p>
<p>新建一个 JavaScript 文件（如<code>app.js</code>），在其中写入 JavaScript 代码。保存后，在 CMD 输入<code>node app.js</code>，即可执行该文件。可见，虽然现在的宿主环境由之前的浏览器变成了 Node.js，但是 ECMAScript 的基本语法与之前是完全一样的，只不过缺少了 DOM 和 BOM 等浏览器提供的接口，取而代之的是 Node.js 提供的服务器相关接口。</p>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>虽然 <a href="/posts/j5h1kgw7.html#模块化">ES6</a> 已经提出了模块化相关的功能，但是 Node.js 在创建早期就已经实现了自己特有的模块化方式 CommonJS。由于历史原因，即使是最新版本（v12.14.1）的 Node.js 也无法原生支持 ES6 模块化的语法，因此这里依然需要使用 CommonJS。</p>
<pre><code class="js">// 要导入的模块，includes.js
const msg = &#39;这是要传递的信息啦&#39;

// 使用 module.exports 导出模块对象
module.exports = {
    msg // ES6 的对象简洁表示法
}</code></pre>
<pre><code class="js">// 导入模块，require() 的返回值就是模块导出的 module.exports 对象。该对象用于模块向外传递数据
const includes = require(&#39;./includes.js&#39;) // =&gt; { msg: &#39;这是要传递的信息啦&#39; }</code></pre>
<p>其中<code>require()</code>方法根据参数不同，查找模块的方式也略有不同。如果传入的是一个路径，则：</p>
<ul>
<li>如果是完整路径，则直接查找该文件</li>
<li>如果省略了后缀名，那么会先查找同名的<code>.js</code>文件，再查找同名文件夹</li>
<li>如果找到了文件夹，则找其中的<code>index.js</code>文件</li>
<li>如果没有找到，则找其中的<code>package.json</code>文件，寻找<code>main</code>属性配置的入口文件</li>
<li>如果没有找到配置文件或入口文件，则报错</li>
</ul>
<p>如果传入的是一个名称，那么引擎会认为这是一个系统模块或第三方模块，并在当前的<code>node_modules</code>文件夹中先查找同名文件，再查找同名文件夹，之后的步骤与上面一样。因此，<strong>如果要加载的是当前路径下的模块，必须要传入<code>./</code>表示当前路径，否则会被识别成模块名。</strong></p>
<h2 id="系统模块"><a href="#系统模块" class="headerlink" title="系统模块"></a>系统模块</h2><p>Node.js 将很多系统功能封装成了单独的模块，需要时加载即可。注意，与浏览器环境不同，Node.js 中的全局对象不再是<code>window</code>，而是<code>global</code>。它也包含类似于定时器的全局方法，不要与<code>window</code>混淆。</p>
<h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>Node.js 通过<code>Path</code>模块提供与路径相关的功能。</p>
<pre><code class="js">// 全局属性，当前模块的物理路径
__dirname // =&gt; 假如 当前文件路径为 D:\htdocs\test.js，则变量的值为 D:\htdocs

// 导入模块
const path = require(&#39;path&#39;)

// 自动忽略掉每个部分两端的路径分隔符，并使用 当前系统环境的分隔符 将其拼接起来
path.join(__dirname, &#39;dist&#39;, &#39;index.html&#39;) // =&gt; D:\htdocs\dist\index.html

// 将若干路径片段拼接成绝对路径，参数会从右向左拼接，一旦发现绝对路径（开头为`/`），则停止解析
path.resolve(&#39;foo&#39;, &#39;/src&#39;, &#39;dist&#39;) // =&gt; D:\src\dist
// 如果没有发现绝对路径，那么以当前工作目录（命令行的执行位置）作为绝对路径拼接
path.resolve(&#39;dist&#39;) // 假如当前命令行指向 D:\WorkSpace\test，则拼接后的值为 D:\WorkSpace\test\dist</code></pre>
<h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>Node.js 通过<code>URL</code>模块提供与 URL 相关的功能。</p>
<pre><code class="js">// 导入模块
const url = require(&#39;url&#39;)

const result = url.parse(&#39;https://user:pass@sub.example.com:8080/p/a/t/h?id=233#hash&#39;) // =&gt; {
//   protocol: &#39;https:&#39;,
//   slashes: true,
//   auth: &#39;user:pass&#39;,
//   host: &#39;sub.example.com:8080&#39;,
//   port: &#39;8080&#39;,
//   hostname: &#39;sub.example.com&#39;,
//   hash: &#39;#hash&#39;,
//   search: &#39;?id=233&#39;,
//   query: &#39;id=233&#39;,
//   pathname: &#39;/p/a/t/h&#39;,
//   path: &#39;/p/a/t/h?id=233&#39;,
//   href: &#39;https://user:pass@sub.example.com:8080/p/a/t/h?id=233#hash&#39; }

// 如果传入第二个参数 true，则表示以对象方式获取 query 查询参数部分
const result = url.parse(&#39;https://sub.example.com:8080?id=233&#39;, true)
result.query // =&gt; { id: 233 }</code></pre>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>Node.js 通过<code>fs</code>模块提供与文件操作相关的功能。</p>
<pre><code class="js">// 导入模块
const fs = require(&#39;fs&#39;)

// 读取文件
fs.readFile(&#39;./test.txt&#39;, &#39;utf8&#39;, function(err, content) {
    if (err) {
        // 如果出现错误
    } else {
        // 否则获取文件内容
    }
})

// 写入文件
fs.writeFile(&#39;./test.txt&#39;, &#39;这里是文件内容啦&#39;, function(err) {
    if (err) {
        // 如果出现错误
    } else {
        // 否则进行相关操作
    }
})</code></pre>
<h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><p>Node.js 通过<code>util</code>模块提供各种常用的工具。</p>
<pre><code class="js">// 导入模块
const util = require(&#39;util&#39;)

// 将 Node.js 中原本的异步任务改造成返回 Promise 对象的函数
const readFile = util.promisify(fs.readFile) // 包装后的新异步任务
readFile().then()</code></pre>
<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>Node.js 也有很多其它开发者提供的第三方功能，由于这些功能通常由多个模块组成，因此将它们统称为包。Node.js 内置了<a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a>（Node Package Manager）包管理工具，使用它可以方便地在公共平台上下载第三方包。</p>
<pre><code class="powershell">npm install 包名称      # 在终端当前路径安装对应的包，会自动保存到该目录下的 node_modules 文件夹下
npm i 包名称            # 上面命令的简写
npm i 包名称 -g         # -g 表示全局安装，在任何路径下都可以使用
npm uninstall 包名称    # 卸载安装的包</code></pre>
<p>模块分为<strong>项目依赖</strong>和<strong>开发依赖</strong>。项目依赖表示开发和实际环境都需要使用的模块（比如 jQuery），这也是上述默认的安装方式；而开发依赖仅需要在开发时使用，与实际运行无关（比如之后的 Gulp 等自动化构建工具），需要在安装命令后添加<code>--save-dev</code>参数。</p>
<pre><code class="powershell">npm i 包名称 --save-dev</code></pre>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>通过配置文件<code>package.json</code>可以直观的看到项目依赖的模块和对应的版本。</p>
<pre><code class="powershell">npm init        # 生成配置文件，根据提示输入信息，按回车表示使用默认值
npm init -y     # 快速生成配置文件，全部使用默认值</code></pre>
<p>项目运行时依赖的模块会保存在配置文件的<code>dependencies</code>属性中，而开发依赖的模块保存到<code>devDependencies</code>属性中。当模块下载或更新后，这些属性自动也会同步更新。</p>
<p>要拷贝项目时，只需要将源代码和该文件复制到新的工作路径，而不需要复制<code>node_modules</code>文件夹，因为通过配置文件可以重新下载这些包。</p>
<pre><code class="powershell">npm install         # 根据配置文件初始化项目，下载依赖的包
npm i               # 上面命令的简写
npm i --production  # 实际部署项目时使用，只下载项目依赖模块，不下载开发依赖模块</code></pre>
<h3 id="切换国内镜像"><a href="#切换国内镜像" class="headerlink" title="切换国内镜像"></a>切换国内镜像</h3><p>由于 npm 默认的下载站点在国外，因此下载速度可能会比较慢，使用第三方包 nrm 可以切换默认的下载节点。</p>
<pre><code class="powershell">npm i nrm -g    # 全局安装
nrm ls          # 列出所有的镜像，* 表示当前正在使用的节点
nrm use taobao  # 切换到淘宝镜像</code></pre>
<h3 id="npx"><a href="#npx" class="headerlink" title="npx"></a>npx</h3><p>使用<code>npx</code>命令可以方便地调用项目内部安装的模块。例如，在项目中安装了局部的 webpack，如果要在命令行中使用，那么必须手动在<code>node_modules</code>中找到 webpack 的可执行文件，因为<strong>只要是在终端直接运行的命令，它会去全局环境中寻找</strong>。由于这里使用了局部安装，因此直接使用<code>webpack</code>命令自然是找不到的。</p>
<pre><code class="powershell"># .bin 是 node_modules 目录下的一个文件夹，里面保存着模块的可执行文件，不是什么特殊的指令 ~
./node_modules/.bin/webpack </code></pre>
<p>如果使用 npx，那么只需要在项目中调用如下命令即可。它的原理非常简单，就是自动到项目的<code>node_modules/.bin</code>以及环境变量中寻找命令是否存在。</p>
<pre><code class="powershell">npx webpack</code></pre>
<h3 id="npm-scripts"><a href="#npm-scripts" class="headerlink" title="npm scripts"></a>npm scripts</h3><p>npm 允许在项目的<code>package.json</code>中，使用<code>scripts</code>属性定义脚本命令。例如，将<code>webpack</code>指令定义为 npm scripts：</p>
<pre><code class="json">// package.json
&quot;scripts&quot;: {
    &quot;build&quot;: &quot;webpack&quot;
},</code></pre>
<p>这样，只需要使用<code>npm run</code>命令就可以执行这段脚本：</p>
<pre><code class="powershell">npm run build   # 相当于执行了 webpack 指令</code></pre>
<p>注意，与在终端中直接运行命令不同的是，npm scripts 会<strong>优先从本地寻找该命令</strong>，如果找不到才会去全局环境中寻找。所以，除了使用<code>npx webpack</code>可以运行本地 webpack 以外，也可以在 npm scripts 中先定义好运行 webpack 的脚本，然后使用<code>npm run build</code>即可运行本地的 webpack。</p>
<h2 id="构建网络服务"><a href="#构建网络服务" class="headerlink" title="构建网络服务"></a>构建网络服务</h2><p>Node.js 不需要像 PHP 一样依赖于 Apache 等服务器软件，它内置了多个模块如<code>Net</code>、<code>Dgram</code>、<code>HTTP</code>和<code>HTTPS</code>分别来处理 TCP、UDP、HTTP 和 HTTPS 的网络请求。</p>
<p>由于诸如 Express 这样的主流框架已经对这些功能进行了高级封装，实际应用中也几乎不可能自己去实现一个服务器，所以如果希望了解原理，请参考<a href="/posts/tb618gp3.html">另一篇文章</a>，本文直接使用<a href="https://expressjs.com/" target="_blank" rel="noopener">Express</a>构建网络服务。</p>
<pre><code class="powershell">npm i express</code></pre>
<h3 id="创建服务器"><a href="#创建服务器" class="headerlink" title="创建服务器"></a>创建服务器</h3><p>下面的代码可以创建一个最简单的服务器，Express 会自动设置 MIME 类型、编码和状态码，对于没有配置的路径，也会自动返回<code>404</code>状态码和错误页面。</p>
<pre><code class="js">// 导入模块
const express = require(&#39;express&#39;)
// 创建服务器对象
const app = express() 
// 定义端口号
const port = 3000 

// 监听端口
app.listen(port, function() {
    console.log(`服务器启动成功，正在监听 ${port} 端口`)
})</code></pre>
<h3 id="页面路由"><a href="#页面路由" class="headerlink" title="页面路由"></a>页面路由</h3><p>路由指的是资源和路径之间的对应关系，资源可能是一个 HTML 页面、一个普通字符串或者一段 JSON 数据等等。</p>
<p>使用<code>METHOD()</code>方法设置当客户端以特定方式（如<code>GET</code>、<code>POST</code>等）请求特定路径时所返回的内容。这里的<code>METHOD</code>需要替换成具体的方式，其详细列表见<a href="https://expressjs.com/en/4x/api.html#app.METHOD" target="_blank" rel="noopener">官网</a>。</p>
<pre><code class="js">// 匹配 get 请求
app.get(&#39;/home&#39;, function(req, res) {
    // 使用响应对象的 send() 方法返回响应内容，否则客户端会一直停留在等待状态
    // 当 send() 参数为字符串时，返回的 Content-Type 为 text/html ，否则为 application/json
    res.send(&#39;欢迎来到首页！&#39;)
})

app.post(&#39;/login&#39;, function(req, res) {
    res.send(&#39;登录成功！&#39;)
})

app.post(/a/, function(req, res) { // 正则表达式，表示任何包含字符 a 的路径
    res.send(&#39;嗯？&#39;)
})

app.get(&#39;/&#39;, function(req, res) {
    // 重定向到 /home 路由，会自动返回 302 状态码，并使客户端跳转到重定向后的页面
    res.redirect(&#39;/home&#39;)
})</code></pre>
<h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>中间件是位于接收请求和发送响应之间的处理模块，它们通常不会用来处理请求和响应。可以理解成污水到最终排放之间，需要经过层层过滤和处理，这个过程就需要若干个中间件来完成。Express 本身只能完成最简单的功能，因此对于 Express 构建的后端服务来说，本质上就是一系列中间件的调用。</p>
<p>注意，中间件会拦截所有以某路径<strong>开头</strong>的路由，而不仅仅是当前指定的路由。如配置的拦截参数是<code>/test</code>，那么它会拦截所有<code>/test/a</code>、<code>/test/a/b</code>等所有子路由。此外，一旦中间件拦截成功，需要调用<code>next()</code>才能执行后续匹配的其它中间件或路由。</p>
<pre><code class="js">// 拦截了 /test 路由
app.use(&#39;/test&#39;, function (req, res, next) { 
    console.log(&#39;拦截成功！&#39;)
    next() // 除非调用 next(), 否则不会执行下面的 get()
})

app.get(&#39;/test&#39;, function (req, res) {
    res.send(&#39;hello&#39;)
})</code></pre>
<p>注意，如果将上述两个函数调换位置，那么中间件也永远不会被执行，因为路由函数<code>get()</code>表示该路由已经处理完毕，也没有<code>next()</code>函数可供调用。</p>
<p>使用中间件可以将路由对象挂载到指定路由上，路由对象相当于一个小型的<code>app</code>服务器对象。</p>
<pre><code class="js">// 创建路由对象
const router = express.Router() 

// 通过路由对象配置路由规则，而非 app
router.get(&#39;/list&#39;, (req, res) =&gt; {
    res.send(&#39;欢迎来到列表页&#39;)
    req.app // 可以在这里获取 app 对象
})

// 使用中间件拦截所有请求，并交给路由对象处理
app.use(&#39;/&#39;, router)

// 导出路由对象
module.exports = router</code></pre>
<p>通过这一方式可以配置子路由：</p>
<pre><code class="js">// 创建路由对象
const blogRouter = express.Router() 

// 该路由规则匹配 /blog/list
blogRouter.get(&#39;/list&#39;, (req, res) =&gt; {
    res.send(&#39;欢迎来到博客列表页&#39;)
})

// 使用中间件拦截 /blog 请求，而非全部请求
app.use(&#39;/blog&#39;, router)

// 导出路由对象
module.exports = blogRouter</code></pre>
<h3 id="接收参数"><a href="#接收参数" class="headerlink" title="接收参数"></a>接收参数</h3><p>获取 GET 请求参数：</p>
<pre><code class="js">// 请求地址: localhost/index?name=daisy&amp;age=18
app.get(&#39;/index&#39;, function(req, res) {
    req.query // =&gt; { name: daisy, age: 18 }
}) </code></pre>
<p>路由参数是另一种传递 GET 参数的方式，它使参数看起来像是路由的一部分，而不是问号引导的形式。目前主流的前端框架也都实现了这种传递参数的方式，使路径看起来更加的友好。在路由后面使用<code>/:参数</code>作为占位符，当服务器接收到这样的请求时，就会将占位符的部分作为参数了。</p>
<pre><code class="js">// 请求路径: localhost/user/add/233, 233 会被识别为 id 参数
// 请求路径: localhost/user/add, 不会匹配到该路由, 因为没有参数部分
app.get(&#39;/add/:id&#39;, function(req, res) {
    req.params // =&gt; { id: 233 }
})</code></pre>
<p>要获取 POST / PUT 请求参数，需要先安装第三方模块<a href="https://github.com/expressjs/body-parser" target="_blank" rel="noopener">body-parser</a>用来解析 JSON 或 urlencoded 格式的数据：</p>
<pre><code>npm i body-parser</code></pre><pre><code class="js">// 导入模块
const bodyParser = require(&#39;body-parser&#39;)

// 中间件，切记一定要定义在路由模块之前！！
app.use(bodyParser.json())
app.use(bodyParser.urlencoded({ extended: false }))

app.post(&#39;/add&#39;, function(req, res) {
    req.body // =&gt; { name: daisy, age: 18 }
})</code></pre>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>要接收二进制数据，需要先安装第三方模块<a href="https://www.npmjs.com/package/multer" target="_blank" rel="noopener">multer</a>：</p>
<pre><code>npm i multer</code></pre><pre><code class="js">const multer = require(&#39;multer&#39;)
// 设置上传路径，这里指向 public 下的 uploads
const upload = multer({ dest: path.resolve(&#39;public&#39;, &#39;uploads&#39;) })

// 为 post() 添加一个中间件，表示接收单个文件，参数为上传的属性名称
// 此时文件会被自动保存到上面的目录中，如果前端需要预览，将该目录托管为静态资源，然后配置路由访问即可
router.post(&#39;/upload&#39;, upload.single(&#39;file&#39;), (req, res) =&gt; {
    res.send(req.file) // 上传的文件信息
})</code></pre>
<h3 id="允许跨域请求"><a href="#允许跨域请求" class="headerlink" title="允许跨域请求"></a>允许跨域请求</h3><p>使用第三方包<a href="https://www.npmjs.com/package/cors" target="_blank" rel="noopener">cors</a>可以配置允许跨域请求。</p>
<pre><code class="powershell">npm i cors</code></pre>
<pre><code class="js">app.use(cors()) // 切记在路由模块之前配置
app.use(&#39;/&#39;, router)</code></pre>
<h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><p>使用<code>express.static()</code>方法可以自动配置静态资源的路由，这是目前 Express 唯一的内置中间件函数，需要作为中间件使用。</p>
<pre><code class="js">// 拼接静态资源目录, 如 D:\WorkSpace\my-project\public
const staticPath = path.join(__dirname, &#39;public&#39;)
// 使用 static() 管理静态资源目录，这是一个中间件函数，需要放到 use() 中执行
app.use(express.static(staticPath))</code></pre>
<p>此时，Express 会自动拦截如<code>/300.png</code>、<code>/css/a.css</code>、<code>/index.html</code>这些路由，并自动返回静态资源的目录下对应的文件。</p>
<pre><code>Test
├─ app.js
├─ public
│    ├─ 300.png
│    ├─ css
│    │    └─ layout.css
└─   └─ index.html</code></pre><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p>实际当中，我们很少将内容完全固定的页面直接返回，而通常是先从数据库查询出需要的数据，然后填充到页面结构中，再将整个页面响应给客户端。与 PHP、JSP 等语言不同，Node.js 并没有这类将前端页面和后端语言结合的语法，因此需要借助模板引擎来实现这一功能。</p>
<p>也就是说，我们不再写直接交给客户端的 HTML 页面，而是按照模板引擎的语法写出页面，将其交给模板引擎。模板引擎会根据其中的代码进行数据拼接等操作，然后将其处理成最终的页面响应给客户端。</p>
<p>或者，如果你采用了「前后端分离」的开发模式（前端只通过接口获取 JSON 数据，而不是直接获取渲染后的页面），那么也可以将模板引擎部署在浏览器端。否则必须通过 JavaScript 动态创建元素，将数据存放在元素中，再追加到页面上。而这样并不利于文档结构的维护，因此同样需要借助模板引擎拼接 HTML 和数据。</p>
<p>模板引擎有很多种，比如<a href="https://ejs.co/" target="_blank" rel="noopener">EJS</a>、<a href="http://www.nooong.com/docs/jade_chinese.htm" target="_blank" rel="noopener">Jade</a>等等，它们的用法大同小异，这里使用的是国内制作的<a href="/posts/3q4y7l2d.html">art-template</a>。</p>
<pre><code class="powershell">npm install express-art-template art-template</code></pre>
<p>使用下面的代码在 Express 中部署 art-template 模板引擎。这些参数均为 Express 中<a href="http://expressjs.com/en/5x/api.html#app.set" target="_blank" rel="noopener">要求配置的参数</a>，并不属于 art-template 模板引擎，因此其它模板引擎配置的方式也基本一样。</p>
<pre><code class="js">// 设置要渲染的文件后缀名，以及对应的模板引擎，必须设置
app.engine(&#39;html&#39;, require(&#39;express-art-template&#39;))

// 设置模板的存放目录，默认值为 process.cwd() + &#39;/views&#39;
// process.cwd() 为当前 Node.js 的进程工作目录，也就是项目根目录下的 views 文件夹
app.set(&#39;views&#39;, path.join(__dirname, &#39;views&#39;))

// 设置要渲染的文件后缀名省略时，默认补充的后缀
app.set(&#39;view engine&#39;, &#39;html&#39;)

// 使用 render() 方法响应模板内容，后面传入数据参数
// 如果 views 下面还有子目录 home，那么要使用 res.render(&#39;home/index.html&#39;)，不要在 home 前添加斜杠了
app.get(&#39;/&#39;, (req, res) =&gt; {
    res.render(&#39;index.html&#39;, { name: &#39;aui&#39;, age: 18 }) // 这里使用了后缀名，如果省略，则根据 view engine 的配置自动补充
})

// 将每个模板都需要使用的公共数据放到 app.locals 对象中，这样每个模板都能直接获取到该数据
app.locals.user = { name: &#39;啦啦啦&#39;, age: 18 } // 在模板中使用 user 即可获取到该对象</code></pre>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>在我们浏览网站时，经常会见到这样一些功能：如果用户登录成功了，那么在某段时间内，用户不再需要重复登录。或者，用户只有在登录之后才能访问特定的页面。</p>
<p>这些需求看似常见，然而并不容易实现。因为 <strong>HTTP 协议是无状态的</strong>，当客户端与服务器的一次请求结束后，服务器就不再认识客户端了。也就是说，虽然用户本次登录成功了，但是服务器无法知道本次与下次登录的是不是同一个用户，只能当作一个新用户来要求其重新登录。或者，如果用户直接访问登录后的页面，那么服务器也无法判断这个用户是否已经登录成功。</p>
<blockquote>
<p>为了理解这个问题，可以看生活中的一个例子：有一家烤鸭店搞活动，只要一个顾客购买 5 只烤鸭，就可以免费再获得 1 只。但是客人这么多，烤鸭店要如何记住每一个客人呢？店铺可以制作一些带有卡号的会员卡，然后在店里准备一个记录本，将顾客的会员卡号与购买的烤鸭数记录下来。这样，当顾客购买烤鸭前，先出示一下会员卡，这样店铺就知道顾客之前购买过几只烤鸭了，从而判断是否要赠送烤鸭。</p>
</blockquote>
<p>其实解决方案与上述例子很相似，为了使服务器（烤鸭店）记住客户端（顾客），那么也要准备一个记录本和会员卡，记录本是服务器的 session 对象，以 sessionID 识别用户，它可以位于服务器内存、文件、数据库，甚至专门的服务器集群中；而会员卡是客户端的本地存储 cookie。当用户首次登录（购物）后，服务器会生成一个随机的 sessionID（卡号），记录到客户端的 cookie 中（会员卡）。</p>
<p>当客户端再次发送 HTTP 请求时，会将本地<strong>同域</strong>的 cookie 携带在请求头中，一同发送到服务器（出示会员卡）。于是服务器可以检查 session 中（记录本）是否包含之前生成的 sessionID（卡号），如果找到了，则说明用户之前登录成功过（购买过烤鸭）。</p>
<blockquote>
<p>session 的本义是「会话」，而无论是服务端的 session 对象，还是 cookie 中记录的 sessionID，都是 session 的<strong>具体实现</strong>。session 的实现并不一定需要依赖于 cookie，只不过 cookie 是目前最简单有效的实现方式之一。</p>
</blockquote>
<p>在 Node.js 中要实现服务端 session，需要安装扩展包<a href="https://www.npmjs.com/package/express-session" target="_blank" rel="noopener">express-session</a>。</p>
<pre><code class="powershell">npm i express-session</code></pre>
<pre><code class="js">// 导入模块
const session = require(&#39;express-session&#39;)

// session() 的构造函数是中间件函数，需要传入 use() 中执行
app.use(session({ 
    secret: &#39;open-sesame&#39;,      // 增加生成 sessionID 的强度，防止被篡改，类似于盐值
    resave: false,              // cookie 过期之前，客户端再次访问是否重复保存 session，建议 false
    saveUninitialized: false    // 是否保存未添加实际内容的 session，建议 false,
    cookie: { 
        maxAge: 24 * 60 * 60 * 1000, // 默认关闭浏览器就会清除，因此要设置 cookie 过期时间，单位为毫秒
    } 
}))

// 当登录成功后，可以在 session 中记录一个值，如用户名
app.post(&#39;/login&#39;, function (req, res) {
    // 如果登录成功
    if (isValid) {
        req.session.username = result.username
        // 跳转到登录后页面
    }
})

// 清除客户端保存的 cookie
app.get(&#39;/&#39;, function (req, res) {
    res.clearCookie(&#39;connect.sid&#39;) // 清除客户端保存的 sessionID
})</code></pre>
<p><img src="https://ae01.alicdn.com/kf/H714549ade3d8483bb2d87b604fb6a11df.jpg" alt=""></p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>Node.js 与其它后端语言一样，都可以与数据库进行交互。由于 MongoDB 是直接操作 JSON 数据，因此与 Node.js 结合使用会更加方便。</p>
<p>MongoDB 本身提供了连接 Node.js 的一系列接口，但是原生代码一向比较复杂。因此与 Express 一样，这里直接使用第三方模块<a href="https://mongoosejs.com/" target="_blank" rel="noopener">Mongoose</a>操作 MongoDB，对于 MongoDB 本身的安装与使用，请查看<a href="/posts/e6q2910w.html">另一篇文章</a>。</p>
<pre><code class="powershell">npm install mongoose</code></pre>
<pre><code class="js">// 导入模块
const mongoose = require(&#39;mongoose&#39;)

// 连接数据库，MongoDB 不需要手动创建数据库，因此这里的数据库名称可以随意填写，插入文档后会自动创建
// 参数用于清除一些警告信息，需要的时候加上即可
mongoose.connect(&#39;mongodb://localhost/test&#39;, { useNewUrlParser: true, useUnifiedTopology: true })
// 如果数据库有密码
mongoose.connect(&#39;mongodb://admin:123456@localhost/test&#39;, { useNewUrlParser: true, useUnifiedTopology: true })</code></pre>
<h3 id="Schema"><a href="#Schema" class="headerlink" title="Schema"></a>Schema</h3><p>由于 MongoDB 本身对存入的数据没有任何约束，因此即便传入错误的数据（甚至是某些字段没有传入），MongoDB 也都会将它们保存起来。为了解决这一问题，Mongoose 引入了规则（Schema）这一概念，它类似于表结构，规定了一个集合（表）的字段类型。</p>
<pre><code class="js">// 创建了一个 游戏 的规则，用来验证字段类型
const GameSchema = new mongoose.Schema({
    // MongoDB 中的 id 并不是一个简单的字符串，因此 Mongoose 提供了该类型
    id: mongoose.ObjectId,
    // 字符串类型，如果传入了非字符串值会自动调用 toString()
    gameName: String, 
    gameType: String,
    // 布尔类型，除了下列值会自动转换以外，其它任何值都会导致转换错误
    // true: &#39;true&#39;, 1, &#39;1&#39;, yes 
    // false: &#39;false&#39;, 0, &#39;0&#39;, no 
    isPublished: Boolean, 
    // 日期类型
    publishDate: Date,
    // 数字类型，null, undefined 不会被转换, NaN 和没有 valueOf() 的数组或对象会导致转换错误
    endings: Number
})</code></pre>
<p>字段的值还可以是一个对象，用来作出更详细的约束。这里只列出较为常见的约束，全部类型详见<a href="https://mongoosejs.com/docs/schematypes.html" target="_blank" rel="noopener">官方文档</a>。</p>
<pre><code class="js">// 更详细的验证规则
const GameSchema = new mongoose.Schema({
    gameName: {
        // [通用]字段类型
        type: String,
        // [通用]要求该字段必须提供，且值不能为 null, undefined, &#39;&#39;
        required: true,             
        // [通用]如果 插入文档 (更新文档无效) 时该字段为 undefined （对`null`或`&#39;&#39;`无效），使用该默认值
        default: &#39;Resident Evil&#39;, 
        // [字符串]最小 / 最大字符数，汉字也算 1 个字符  
        minlength: 2,               
        maxlength: 50,
        // [字符串]是否自动去除字符串两端空格
        trim: true,   
        // [字符串]是否转换大小写
        lowercase: true,
        uppercase: true,
        // [字符串]是否匹配给定的正则表达式
        match: /\d{1, 13}/
    },
    gameType: {
        // [字符串, 数值]只能是给定的值之一, 对于 null 和 undefined 无效
        enum: [&#39;ACT&#39;, &#39;RPG&#39;]        
    }
    endings: {
        // [通用]自定义验证规则
        validate: {    
            // v 表示要验证的值, 如果传入的值大于 3, 表示验证通过
            validator: v =&gt; { return v &gt; 3 },
            // 验证失败时的错误信息     
            message: &#39;什么破游戏, 连 3 个结局都没有!&#39;    
        },
        // [通用]获取或存入数据时，对其进行处理
        get: v =&gt; Math.round(v),    
        set: v =&gt; Math.round(v),
        // [数值]最大最小值
        min: 3,                     // 最小值
        max: 10,                    // 最大值
    }
})</code></pre>
<p>上述<code>required</code>、<code>max</code>、<code>min</code>、<code>enum</code>、<code>match</code>、<code>minlength</code>和<code>maxlength</code>会调用内置的验证器，将这些值放到数组中，并传入第二个字符串元素，可以自定义这些验证器的错误信息。</p>
<pre><code class="js">const GameSchema = new mongoose.Schema({
    endings: {
        max: [99, &#39;最大值不能超过99啦&#39;]
        enum: [[22, 33], &#39;只能是 22 或者 33&#39;]
    }
})

// 在下面增删查改的方法中可以使用 错误对象.errors.字段名.message 获取到错误提示信息
GameModel.create({ endings: 666 }).catch(err =&gt; {
    err.errors.endings.message
})</code></pre>
<h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>将定义的规则传入<code>model()</code>方法可以创建一个模型（Model），模型是 Mongoose 特有的概念，可以理解成集合（表）。使用模型就可以对数据库进行增删查改操作了。</p>
<p>注意，MongoDB 中不能使用 SQL 中的<code>where</code>来限定条件，取而代之的是<a href="/posts/e6q2910w.html#查询操作符">查询操作符</a>语法。</p>
<pre><code class="js">// 第一个参数为集合（表）名称，建议采用 首字母大写的单数形式，Mongoose 会将其转换成 全部小写的复数形式，与数据库中的集合对应
const GameModel = mongoose.model(&#39;Game&#39;, GameSchema) // 数据库对应的集合名称为 games

// 插入文档
GameModel.create(   // 参数可以是若干个单独的对象
    { name: &#39;Resident Evil&#39;, isPublish: true, endings: 1 },
    { name: &#39;Enter the Gungeon&#39;, isPublish: true, endings: 8 },
)
    .then((p1, p2) =&gt; {})  // 参数为插入的对象
    .catch(err =&gt; {})

GameModel.create(   // 也可以是一个对象数组
    [
        { name: &#39;Resident Evil&#39;, isPublish: true, endings: 1 },
        { name: &#39;Enter the Gungeon&#39;, isPublish: true, endings: 8 }
    ],
)

// 查询多条文档，其中的参数为 MongoDB 中的 查询操作符，省略表示查询全部
// 无论查询结果是多条、单条还是没有，均为对象数组
GameModel.find({ name: &#39;Enter the Gungeon&#39; })
    .then(result =&gt; {}) 
    .catch(err =&gt; {})

// 查询一条文档，如果有多个符合条件的文档，只返回其中的第一条
GameModel.findOne({ name: &#39;Enter the Gungeon&#39; })

// 根据 id 查询一条文档，与 findOne({ _id: id }) 效果相同
GameModel.findById(&#39;5db6cbb42b004b2840128f79&#39;)

// 获取文档数量
GameModel.countDocuments({ ending: 3 })
    .then(count =&gt; {}) // 符合条件的文档数

// 修改一条文档
// 第一个参数为查询条件，第二个参数是修改后的值
GameModel.updateOne({ _id: &#39;5d9f6b147589b70e201eca72&#39; }, { name: &#39;Biohazard&#39; })

// 根据 id 查询一条文档并修改
GameModel.findByIdAndUpdate(&#39;5db6cbb42b004b2840128f79&#39;, { name: &#39;Biohazard&#39; })

// 修改多条文档
GameModel.updateMany({ type: &#39;AVG&#39; }, { name: &#39;Biohazard&#39; })

// 删除一条文档，参数为查询条件，如果省略则表示删除全部文档的第一条
GameModel.deleteOne({ endings: 3 })

// 根据 id 查询一条文档并删除
GameModel.findByIdAndDelete(&#39;5db6cbb42b004b2840128f79&#39;)

// 删除多条文档，参数为查询条件，如果省略则表示不删除
GameModel.deleteMany({ endings: 3 })</code></pre>
<h3 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h3><p>上述的增删改查方法几乎全部返回一个<code>Query</code>对象，它是 Mongoose 提供的一个查询结果对象，其中包含了一些处理查询结果的常用方法，并且封装了<code>then()</code>和<code>catch()</code>，可以当作<code>Promise</code>来使用，但它并不是真正的<code>Promise</code>。</p>
<pre><code class="js">// 过滤查询字段
GameModel.find().select(&#39;name type&#39;) // 仅查询所有文档的 name 和 type 字段
GameModel.find().select(&#39;-name&#39;) // 不查询所有文档的 name 字段

// 排序查询结果
GameModel.find().sort(&#39;endings&#39;) // 将查询结果按照结局数 升序(由小到大) 排序
GameModel.find().sort(&#39;-endings&#39;) // 将查询结果按照结局数 降序(由大到小) 排序

// 跳过特定的文档数
// { _id: 5e4685ffd96f66282c100c61, endings: 3 },
// { _id: 5e468608bc19a50e64ae6263, endings: 233 },
// { _id: 5e46860c31150e222cd388f1, endings: 0 }
GameModel.find().skip(1) // 跳过第一条，即没有 endings: 3 这一条

// 限制查询的结果数
GameModel.find().limit(1) // 只查询 1 条文档，相当于 findOne()</code></pre>
</div>
    </div>
</div>

<div class="toc"></div>
    <footer>
    <p>© 2020</p>
    <p>Theme chicken by 小鸡米花, Powered by Hexo</p>
</footer>
    <a class="back-to-top" href="javascript:;"></a>

    <script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
    <script defer src="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.js"></script>
    <script defer src="https://cdn.staticfile.org/KaTeX/0.11.1/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, { strict: false, delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}] });"></script>
    <script src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js"></script>
    <script src="https://cdn.staticfile.org/highlight.js/9.18.1/highlight.min.js"></script>

    <script>
        // 为标签追加字体图标
        $('.tag-list-item').prepend('<i class="fas fa-tag"></i>')

        // 回到顶部的猫
        $('.back-to-top').click(function () {
            $('html, body').animate({
                scrollTop: 0
            }, 500)
        })

        // 监听 回到顶部的猫 是否显示
        $(document).scroll(function () {
            if ($(document).scrollTop() > 50) {
                $('.back-to-top').addClass('show')
            } else {
                $('.back-to-top').removeClass('show')
            }
        })

        // 在表格外包裹一层，用来生成滚动条
        $('.post-content > table').wrap('<div class="table-container"></div>')

        // Tocbot 实例化，用来快速生成文档目录
        tocbot.init({
            tocSelector: '.toc', // 渲染目录的容器
            contentSelector: '.post-content', // 标题所在的容器
            headingSelector: 'h2, h3', // 要渲染的目录层级,
            headingsOffset: -50, // 微调目录高亮的显示位置（偏移量），防止点击的链接和高亮的链接不一致
        })

        // 初始化代码高亮 highlight.js
        hljs.initHighlightingOnLoad()

        // 自动加载 waifu
        try {
            $("<link>").attr({ href: "//cdn.yesuanzao.cn/blog/live2d/waifu.min.css", rel: "stylesheet", type: "text/css" }).appendTo('head');
            $('body').append('<div class="waifu"><div class="waifu-tips"></div><canvas id="live2d" class="live2d"></canvas><div class="waifu-tool"><span class="fui-home"></span> <span class="fui-chat"></span> <span class="fui-eye"></span> <span class="fui-user"></span> <span class="fui-photo"></span> <span class="fui-info-circle"></span> <span class="fui-cross"></span></div></div>');
            $.ajax({ url: '//cdn.yesuanzao.cn/blog/live2d/waifu-tips.js', dataType: "script", cache: true, async: false });
            $.ajax({ url: '//cdn.yesuanzao.cn/blog/live2d/live2d.min.js', dataType: "script", cache: true, async: false, success: function() {
                initModel('//cdn.yesuanzao.cn/blog/live2d/waifu-tips.json');
            } });
        } catch (err) { console.log(err) }
    </script>
    <!-- 
        添加控制台，测试移动端
        <script src="http://cdn.jsdelivr.net/npm/eruda"></script>
        <script>eruda.init();</script>
    -->
</body>

</html>