<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>这是一个神奇的主题</title>
    <link rel="stylesheet" href="//cdn.yesuanzao.cn/blog/chicken.css">
    <link rel="stylesheet" href="/css/iconfont.css">
    <link rel="stylesheet" href="//cdn.yesuanzao.cn/blog/atom-one-dark.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css">
<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <header>
    <div class="container">
        <div class="site-title"><a href="/">小鸡米花的知识库</a></div>
        <nav>
            <a class="nav-item " href="/">主页</a>
            <a class="nav-item " href="/archives">时光轴</a>
        </nav>
    </div>
</header>
    <div id="write">
    <div class="container">
        <div class="post-info">
            <ul class="tag-list">
                
                    <a class="tag-list-item" href="/tags/CSS/">CSS</a>
                
            </ul>
        </div>
        <div class="post-content"><h1 id="大前端支线笔记之01-🧱-CSS-包含块"><a href="#大前端支线笔记之01-🧱-CSS-包含块" class="headerlink" title="大前端支线笔记之01 🧱 CSS 包含块"></a>大前端支线笔记之01 🧱 CSS 包含块</h1><p>包含块（containing block）是 CSS 布局中比较重要的一个概念，因为一个元素的布局或宽高均是由自身的包含块决定的。在不同的布局方式中，一个元素的包含块也会有所不同。</p>
<h2 id="普通文档流"><a href="#普通文档流" class="headerlink" title="普通文档流"></a>普通文档流</h2><p>在普通文档流中，一个元素的包含块是其<strong>最近父元素的内容区</strong>。此时，子元素在<strong>水平方向</strong>上的<code>margin</code>、<code>border</code>、<code>padding</code>和<code>width</code>之和必须与包含块的宽度相等。</p>
<p>由于其中的<code>border</code>和<code>padding</code>只能是固定值，而<code>margin</code>和<code>width</code>能够设置为<code>auto</code>，表示根据情况来调整自身大小，以确保这个等式被满足。</p>
<p>注意，只要<code>margin</code>与任何其它属性同时为<code>auto</code>，那么<code>margin</code>的<code>auto</code>会被视为<code>0</code>。</p>
<p>首先，当只有一个值为<code>auto</code>时，该值会自动调整宽度，以满足等式。</p>
<pre><code class="html">&lt;div&gt;
    &lt;p&gt;&lt;/p&gt;
&lt;/div&gt;</code></pre>
<pre><code class="css">div { width: 500px; }
p {
    margin-left: auto; /* auto 会被计算为 300px */
    margin-right: 100px;
    width: 100px;
}</code></pre>
<p>当两个<code>margin</code>的值为<code>auto</code>时，那么它们会<strong>等分剩余的距离</strong>以满足等式，从而使该元素在包含块中居中，这是<strong>块级元素水平居中方式</strong>之一。</p>
<pre><code class="css">div { width: 500px; }
p {
    margin-left: auto; 
    margin-right: auto; /* 左右外边距均是（ 500-300 ）/ 2 = 100px */
    width: 300px;
}</code></pre>
<p>当三个属性都为固定值，而且加起来也不够包含块的宽度，此时浏览器会<strong>强制将<code>margin-right</code>设置为<code>auto</code></strong>，以满足等式。</p>
<pre><code class="css">div { width: 500px; }
p {
    margin-left: 100px; 
    margin-right: 100px; /* 右外边距会被强行设置为 auto，从而被计算为 300px */
    width: 100px;
}</code></pre>
<p>如果三个固定值加起来超过了包含块宽度，那么子元素就会超出包含块，导致一部分位于包含块外部。</p>
<h2 id="定位元素"><a href="#定位元素" class="headerlink" title="定位元素"></a>定位元素</h2><p>定位元素的包含块与普通文档流有所不同：</p>
<ul>
<li>绝对定位：为最近的<strong>定位</strong>父元素，直到最外层的<code>&lt;html&gt;</code>元素<ul>
<li>如果父元素是块级盒子，那么包含块是父元素的<strong>内边距</strong></li>
<li>如果父元素是行内盒子，那么包含块是父元素的<strong>内容区</strong></li>
</ul>
</li>
<li>相对定位：为最近的父元素内容区</li>
<li>固定定位：为浏览器窗口</li>
</ul>
<p>与普通文档流一样，定位元素也要满足包含块的等式。但是，普通文档流的等式仅针对水平方向，而定位元素的公式也同时适用于<strong>垂直方向</strong>。</p>
<p>以水平方向为例，定位元素水平方向上的<code>margin</code>、<code>border</code>、<code>padding</code>、<code>width</code>、<code>left</code>和<code>right</code>之和必须与包含块宽度相等。</p>
<p>其中<code>border</code>和<code>Padding</code>的值只能是固定值，而<code>margin</code>、<code>width</code>、<code>left</code>和<code>right</code>都能够设置为<code>auto</code>从而根据情况来调整自身大小，以确保这个等式被满足。注意，只要<code>margin</code>和任何一个属性都为<code>auto</code>，那么<code>margin</code>的<code>auto</code>会被视为<code>0</code>。</p>
<p>当 5 个值（<code>margin-left</code>、<code>margin-right</code>、<code>width</code>、<code>left</code>、<code>right</code>）中只有一个为<code>auto</code>，该值会自动调整宽度，以满足等式。</p>
<pre><code class="css">div { 
    position: relative;
    width: 500px; 
}
p {
    position: absolute;
    left: 0;
    right: 0;
    margin-left: auto; /* auto 会被计算为 300px */
    margin-right: 100px;
    width: 100px;
}</code></pre>
<p>当 2 个<code>margin</code>的值为<code>auto</code>，那么它们会<strong>等分剩余的距离</strong>以满足等式，如果要居中元素，最好将对立的偏移量设置为<strong>同一个值</strong>（比如<code>0</code>）.</p>
<pre><code class="css">p {
    position: absolute;
    left: 0;
    right: 0;
    margin-left: auto; /* ( 500-100 ) / 2 = 200px */
    margin-right: auto; /* 同上 */
    width: 100px;
}</code></pre>
<p>当 2 个偏移量为<code>auto</code>，那么元素位于<strong>定位之前的位置</strong>。相当于仅仅为一个元素设置了绝对定位，而没有设置偏移量。</p>
<p>当<code>width</code>和 1 个偏移量为<code>auto</code>，那么<code>width</code>会收缩到最小，由偏移量满足公式。</p>
<p>当<code>width</code>和 2 个偏移量为<code>auto</code>，那么<code>width</code>会收缩到最小，元素位于定位之前的位置。</p>
<p>当 5 个属性都为固定值，而且加起来也不够包含块的宽度，<code>right</code>会被视为<code>auto</code>。</p>
</div>
    </div>
</div>

<div class="toc"></div>
    <footer>
    <p>© 2020</p>
    <p>Theme chicken by 小鸡米花, Powered by Hexo</p>
</footer>
    <a class="back-to-top" href="javascript:;"></a>

    <script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
    <script defer src="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.js"></script>
    <script defer src="https://cdn.staticfile.org/KaTeX/0.11.1/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, { strict: false, delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}] });"></script>
    <script src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js"></script>
    <script src="https://cdn.staticfile.org/highlight.js/9.18.1/highlight.min.js"></script>

    <script>
        // 为标签追加字体图标
        $('.tag-list-item').prepend('<span class="iconfont icon-biaoqian"></span>')

        // 回到顶部的猫
        $('.back-to-top').click(function () {
            $('html, body').animate({
                scrollTop: 0
            }, 500)
        })

        // 监听 回到顶部的猫 是否显示
        $(document).scroll(function () {
            if ($(document).scrollTop() > 50) {
                $('.back-to-top').addClass('show')
            } else {
                $('.back-to-top').removeClass('show')
            }
        })

        // 在表格外包裹一层，用来生成滚动条
        $('.post-content > table').wrap('<div class="table-container"></div>')

        // Tocbot 实例化，用来快速生成文档目录
        tocbot.init({
            tocSelector: '.toc', // 渲染目录的容器
            contentSelector: '.post-content', // 标题所在的容器
            headingSelector: 'h2, h3', // 要渲染的目录层级,
            headingsOffset: -50, // 微调目录高亮的显示位置（偏移量），防止点击的链接和高亮的链接不一致
        })

        // 初始化代码高亮 highlight.js
        hljs.initHighlightingOnLoad()

        // 自动加载 waifu
        try {
            $("<link>").attr({ href: "//cdn.yesuanzao.cn/blog/live2d/waifu.min.css", rel: "stylesheet", type: "text/css" }).appendTo('head');
            $('body').append('<div class="waifu"><div class="waifu-tips"></div><canvas id="live2d" class="live2d"></canvas><div class="waifu-tool"><span class="fui-home"></span> <span class="fui-chat"></span> <span class="fui-eye"></span> <span class="fui-user"></span> <span class="fui-photo"></span> <span class="fui-info-circle"></span> <span class="fui-cross"></span></div></div>');
            $.ajax({ url: '//cdn.yesuanzao.cn/blog/live2d/waifu-tips.js', dataType: "script", cache: false, async: false });
            $.ajax({ url: '//cdn.yesuanzao.cn/blog/live2d/live2d.min.js', dataType: "script", cache: false, async: false, complete: function() {
                initModel('//cdn.yesuanzao.cn/blog/live2d/waifu-tips.json');
            } });
        } catch (err) { console.log(err) }
    </script>
    <!-- 
        添加控制台，测试移动端
        <script src="http://cdn.jsdelivr.net/npm/eruda"></script>
        <script>eruda.init();</script>
    -->
</body>

</html>