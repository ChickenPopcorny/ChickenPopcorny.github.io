<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>这是一个神奇的主题</title>
    <!-- <link rel="stylesheet" href="//cdn.yesuanzao.cn/blog/chicken.css"> -->
    <link rel="stylesheet" href="//cdn.yesuanzao.cn/blog/atom-one-dark.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css">
    <!-- 本地静态文件测试 -->
    <link rel="stylesheet" href="/css/chicken.css">
<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <header>
    <div class="container">
        <div class="site-title"><a href="/">小鸡米花的知识库</a></div>
        <nav>
            <a class="nav-item " href="/">主页</a>
            <a class="nav-item " href="/archives">时光轴</a>
        </nav>
    </div>
</header>
    <div id="write">
    <div class="container">
        <div class="post-info">
            <ul class="tag-list">
                
                    <a class="tag-list-item" href="/tags/JavaScript/">JavaScript</a>
                
            </ul>
        </div>
        <div class="post-content"><h1 id="📜-大前端笔记之-JavaScript"><a href="#📜-大前端笔记之-JavaScript" class="headerlink" title="📜 大前端笔记之 JavaScript"></a>📜 大前端笔记之 JavaScript</h1><p>JavaScript 的主要作用是赋予页面行为。如今经常用 JavaScript 和 ECMASrcipt 表达相同的含义，但实际上 JavaScript 表示的更加广泛：它由三个部分组成，分别是 ECMAScript、DOM 和 BOM。</p>
<p>ECMAScript 定义的是这门语言的基础，包括语法、类型、语句、关键字、保留字、操作符等，而浏览器只是 ECMAScript 的<strong>宿主环境</strong>之一。宿主环境不仅提供 ECMAScript 的实现，同时也会提供 ECMAScript 的 API，以便<strong>ECMAScript 与宿主环境交互</strong>，其它的宿主环境还有 Node.js、Adobe Flash 等。</p>
<p>到 2019 年为止，它总共经历了 10 个版本，目前最新的是 2019 年 6 月发布的 ECMAScript10。其中变革最大的为 2015 年发布的 ECMAScript6，由于后续版本更新速度加快，新特性并不是很多，因此以 ES6 指代后续所有的新版本。接下来为了方便起见，也通常使用 JavaScript 来泛指 ECMAScript。</p>
<p>DOM（Document Object Model，文档对象模型）是浏览器提供的 API，以便 ECMAScript 与浏览器交互。它将整个页面映射成一个多层节点的结构，其中每个部分都是某种类型的节点，这些节点又包含不同类型的数据，通过 DOM 可以轻松地删除、添加、替换或修改任何节点。</p>
<p>BOM（Browser Object Model，浏览器对象模型）也是浏览器提供的一个 API。通过 BOM 可以控制浏览器视口以外的部分，比如浏览器的窗口和框架等等。</p>
<p>要在网页上使用 JavaScript，第一种方式是通过<code>&lt;script&gt;</code>的<code>src</code>属性引入外部 JavaScript 文件：</p>
<pre><code class="html">&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
    &lt;script src=&quot;test.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<blockquote>
<p>按照传统做法，所有<code>&lt;script&gt;</code>元素都应放在<code>&lt;head&gt;</code>元素中。但是，这意味着必须等到全部 JavaScript 都被下载、解析和执行完毕后，页面的内容才会呈现，这样用户在打开页面时就会看到长时间的空白。因此通常把 JavaScript 的引用放到<code>&lt;/body&gt;</code>之前。</p>
</blockquote>
<p>第二种方式是使用<code>&lt;script&gt;</code>并将代码直接写入其中：</p>
<pre><code class="html">&lt;html&gt;
&lt;head&gt;&lt;/head&gt;
&lt;body&gt;
    &lt;script&gt;
        alert(&#39;hello&#39;)
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>ECMAScript 包含了这门语言的基本语法部分。</p>
<h3 id="语句和表达式"><a href="#语句和表达式" class="headerlink" title="语句和表达式"></a>语句和表达式</h3><p>语句是为了执行某个任务而进行的操作，多数语句以分号<code>;</code>结尾，而且<strong>分号可以省略</strong>，省略与否取决于个人习惯。</p>
<pre><code class="js">var a = 3 /* 这是一条语句，执行了将 3 赋值给变量 a 的操作 */</code></pre>
<blockquote>
<p>如果省略了分号，那么切记在<code>[</code>、<code>(</code>、<code>+</code>、<code>-</code>和反引号（模板字符串标记）作为首行开头时，在前面添加一个<code>;</code>，以防解析出错。</p>
</blockquote>
<p>表达式是可以得到计算结果的式子，它一定会返回一个值。也就是说，只要预期为值的地方，都可以替换成表达式。</p>
<pre><code class="js">var a = 1 + 2 /* 将原本的值 3 替换成了表达式 1 + 2 */</code></pre>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量是用来保存值的，相当于为值起一个名字，以便识别和重复使用。JavaScript 中的变量是<strong>弱类型</strong>的，任何数据类型的值都可以使用<code>var</code>关键字声明的变量保存。</p>
<pre><code class="js">// 声明一个变量
var msg = &quot;hello&quot;

// 同时声明多个变量
var msg = &quot;hello&quot;,
    num = 233,
    isIdiot = true</code></pre>
<blockquote>
<p><code>var</code>也可以省略，但是不推荐这样做。因为正常情况下，函数中声明的变量是局部变量。假如省略了<code>var</code>关键字，那么它就不再是一个局部变量，而会成为一个<strong>全局变量</strong>，这会导致代码难以阅读和维护。为此，ES6 提供了其它关键字来声明变量，今后应当尽量避免使用<code>var</code>。</p>
</blockquote>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符是变量和函数的名称，它们的名称需要遵循一系列命名规则，不符合规则的标识符会导致程序报错，无法继续执行。</p>
<ul>
<li>由字母、数字、美元符号<code>$</code>和下划线<code>_</code>组成，不允许以数字开头</li>
<li>不能使用<a href="http://www.ecma-international.org/ecma-262/9.0/index.html#sec-reserved-words" target="_blank" rel="noopener">保留字</a>、<code>true</code>、<code>false</code>、<code>null</code></li>
<li>区分大小写</li>
<li>建议使用驼峰命名法</li>
</ul>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>注释是 JavaScript 引擎忽略的部分，它们不会被解析，可以用来对程序进行说明。其中单行注释以双斜线<code>//</code>开头，多行注释以<code>/*</code>开头，以<code>*/</code>结尾。</p>
<pre><code class="js">// 单行注释

/*
 *  多行注释
 */</code></pre>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>运算符用来对值进行处理，从而得到新的值。</p>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>赋值运算符会将右侧的运算数赋值给左侧的运算数。为了简化代码，可以对算数并赋值的运算进行合并，称为<strong>复合赋值运算符</strong>。</p>
<pre><code class="js">// 普通赋值
var num = 233

// 复合赋值运算符
num += 2 // 相当于 num = num + 2
num -= 2 // 相当于 num = num - 2
num *= 2 // 相当于 num = num * 2
num /= 2 // 相当于 num = num / 2
num %= 2 // 相当于 num = num % 2</code></pre>
<p>赋值运算符可以连续调用，执行顺序是从右向左。但是这样的用法会带来很多意料之外的问题，建议不要使用。</p>
<pre><code class="js">var a = b = c = 2 // 相当于 var a; c = 2; b = c; a = b;</code></pre>
<h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><p>算数运算符用来完成基本的算术运算。</p>
<pre><code class="js">// 加法运算符，如果其中一个运算数为字符串，那么就会将其它的运算数通过`String()`转换为字符串，表示字符串拼接
// 否则，就将所有运算数转换为数值，表示数学运算
1 + 2               // =&gt; 3
1 + false           // =&gt; 1
null + false        // =&gt; 0
&#39;hello&#39; + 1         // =&gt; hello1
&#39;hello&#39; + false     // =&gt; hellofalse

// 自增减运算符。当它放在运算数左侧时，表示先自增，后取值；当它放在运算数右侧时，表示先取值，后自增
// 注意，它只能操作变量，不能操作值
var num1 = 8
console.log(num1++) // 先输出，再自增，因此结果是 8

var num2 = 8
console.log(++num2) // 先自增，再输出，因此结果是 9</code></pre>
<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>JavaScript 中的相等运算分为普通相等和严格相等两种。使用严格相等运算时，只有两个运算数的类型和值都相等，才返回<code>true</code>，不会自动进行类型转换。为了防止出现意外情况，应当优先使用<strong>严格相等</strong>。</p>
<pre><code class="js">99 == &#39;99&#39; // =&gt; true
99 === &#39;99&#39; // =&gt; false</code></pre>
<p>当比较两个对象时，<code>==</code>和<code>===</code>效果相同，因为它们都是比较两个引用保存的对象地址。</p>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>逻辑运算符会导致运算数自动调用<code>Boolean()</code>进行数据类型转换。</p>
<p>逻辑与<code>&amp;&amp;</code>和逻辑或<code>||</code>运算符会从左到右依次判断每个条件，如果左侧的某个条件已经确定了整个运算的结果，那么后面的条件就不再执行（即使发生语法错误也不会报错）。因此，可以用<code>&amp;&amp;</code>来完成简单的条件判断：</p>
<pre><code class="js">flag &amp;&amp; foo() // 如果 flag 为 true，则执行 foo()。相当于 if (flag === true) { foo() }</code></pre>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p>程序默认是从上向下依次执行的，使用流程控制语句则可以改变顺序执行结构。</p>
<h4 id="if-结构"><a href="#if-结构" class="headerlink" title="if 结构"></a>if 结构</h4><p>判断条件可以是布尔型的值或者表达式，如果不是，则会自动调用<code>Boolean()</code>进行数据类型转换。</p>
<pre><code class="js">// 最简单的 if 结构
if (age &gt; 18) {
    console.log(&#39;可以进网吧啦&#39;)
}

// 使用 else 可以表示当条件不满足时，所执行的操作
if (age &gt; 18) {
    console.log(&#39;可以进网吧啦&#39;)
} else {
    console.log(&#39;一边玩去！&#39;)
}

// 多个 if else 结合在一起使用，可以表示多次判断
if (age &lt; 18) {
    console.log(&#39;一边玩去！&#39;)
} else if (age &gt;= 18 &amp;&amp; age &lt; 50) {
    console.log(&#39;可以进网吧啦&#39;)
} else if (age &gt;= 50) {
    console.log(&#39;啥？你是来找网瘾少年的吗？&#39;)
}</code></pre>
<h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><p>三元运算符<code>判断条件 ? 表达式1 : 表达式2</code>是<code>if else</code>的简写形式，如果判断条件成立则返回<code>表达式1</code>，否则返回<code>表达式2</code>。</p>
<pre><code class="js">console.log(age &gt;= 18 ? &#39;可以进网吧啦&#39; : &#39;一边玩去！&#39;)</code></pre>
<h4 id="switch-结构"><a href="#switch-结构" class="headerlink" title="switch 结构"></a>switch 结构</h4><p>如果要判断是否为一个具体的值，而非某个范围，那么使用<code>switch</code>可以使结构更加清晰。</p>
<p>注意，如果没有<code>break</code>语句，会导致穿透现象，即当其中一个<code>case</code>满足时，会连带后续的所有<code>case</code>一并执行。此外，<code>switch</code>结构比较结果采用的是<strong>严格相等</strong>，因此比较时不会发生类型转换。</p>
<pre><code class="js">var fruit = &#39;orange&#39;

switch (fruit) {
    // 多个 case 共用一个执行结果
    case &#39;橘子&#39;:
    case &#39;orange&#39;:
        console.log(&#39;橘子五毛一斤&#39;)
        break
    case &#39;banana&#39;:
        console.log(&#39;香蕉一块一斤&#39;)
        break
    // 当所有 case 都不满足，则调用 default 部分
    default:
        console.log(&#39;没这东西！&#39;)
}</code></pre>
<h4 id="while-结构"><a href="#while-结构" class="headerlink" title="while 结构"></a>while 结构</h4><p><code>while</code>循环由两部分组成，圆括号中的循环条件和花括号中的循环体。</p>
<pre><code class="js">var i = 0

while (i &lt; 10) {
    console.log(&#39;这是第&#39; + i + &#39;次循环啦&#39;)
    i++ // 改变循环条件，否则会出现死循环
}</code></pre>
<h4 id="for-结构"><a href="#for-结构" class="headerlink" title="for 结构"></a>for 结构</h4><p>如果有明确的循环次数，那么可以使用更加方便的<code>for</code>循环。</p>
<pre><code class="js">for (var i = 0; i &lt; 10; i++) {
    // 执行 10 次相应代码
}</code></pre>
<h4 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h4><p>使用<code>break</code>和<code>continue</code>语句可以跳出循环。区别在于，<code>break</code>会跳出整个循环体，而<code>continue</code>是跳出本次循环，继续下一次循环。</p>
<pre><code class="js">// continue
for (var i = 1; i &lt;= 5; i++) {
    if (i === 3) {
        console.log(&#39;这个包子有毒！不吃了！吃下一个！&#39;)
        continue
    }
    console.log(&#39;我正在吃第&#39; + i + &#39;个包子。&#39;)
}

// break
for (var i = 1; i &lt;= 5; i++) {
    if (i === 3) {
        console.log(&#39;这个包子有毒！去拉肚子了！剩下的不吃了！&#39;)
        break
    }
    console.log(&#39;我正在吃第&#39; + i + &#39;个包子。&#39;)
}</code></pre>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>JavaScript 中的值分为六种数据类型，其中除了<code>Object</code>之外均为基本类型，包括<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>String</code>和<code>Number</code>，而<code>Object</code>又包含三种类型，狭义的对象、数组和函数。</p>
<blockquote>
<p>虽然<code>Boolean</code>、<code>String</code>和<code>Number</code>是基本数据类型，但是它们均有对应的<strong>包装类</strong>对象。当它们调用方法时，这些值会被临时转换为包装类对象，调用结束后就会被立刻销毁。</p>
</blockquote>
<h4 id="Undefined-和-Null"><a href="#Undefined-和-Null" class="headerlink" title="Undefined 和 Null"></a>Undefined 和 Null</h4><p>JavaScript 中这两个类型均表示「空」，它们都只有一个值，即小写的<code>undefined</code>和<code>null</code>。</p>
<p>对于<code>undefined</code>来说，它通常不需要手动定义，而可能会出现在下列情况：</p>
<ul>
<li>声明了变量，但没有赋值，该变量为<code>undefined</code></li>
<li>数组中的空元素（修改数组长度、跨索引添加元素等）为<code>undefined</code></li>
<li>调用函数时，没有传入实参，那么形参为<code>undefined</code></li>
<li>访问<strong>对象</strong>中未声明的属性，该属性为<code>undefined</code>。如果访问一个未声明的变量，那么会报错</li>
<li>函数没有返回值，则返回<code>undefined</code></li>
</ul>
<p>对于<code>null</code>来说，如果一个对象类型的变量没有指向任何一个实际对象，那么该变量的值就是<code>null</code>。</p>
<h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h4><p>布尔类型<code>Boolean</code>只有<code>true</code>和<code>false</code>两个值。</p>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>使用单引号<code>&#39;&#39;</code>或双引号<code>&quot;&quot;</code>均可创建字符串。不过由于 JSON 格式内部只能使用双引号，因此建议使用单引号创建字符串，否则就要使用转义字符<code>\</code>。</p>
<pre><code class="js">var str = &#39;helloworld&#39;

//使用 length 获取字符串长度
str.length // =&gt; 10</code></pre>
<h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><p>数值类型<code>Number</code>采用<a href="/posts/xp50sskp.html">IEEE 754</a>标准，不区分整数值和小数值，所有数值都是以 64 位浮点数存储，即便是整数也是如此。</p>
<p>全局属性<code>NaN</code>表示非数字（Not a Number），可能出现在某些计算失败（如负数开偶次方）的情况。它并不是独立的数据类型，而是<code>Number</code>类型的一个特殊值。</p>
<p>此外，<code>NaN</code>不等于任何值，包括<strong>它本身</strong>。由于这个特性，JavaScript 提供了全局方法<code>isNaN()</code>用来判断一个值是否为<code>NaN</code>。</p>
<pre><code class="js">isNaN(NaN) // =&gt; true</code></pre>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组以<code>Array</code>内置对象表示。虽然它可以同时存放不同类型的数据，但这样无法对数据进行统一的处理。数组的本质其实是有序的键值对，但是它的特殊之处在于，它的键是有序的数字，而非具体的名称。</p>
<pre><code class="js">// 创建数组
var arr = [10, 30, 233]

// 通过下标访问数组元素
arr[0] // =&gt; 10

// 通过 for 循环遍历数组
for (var i = 0; i &lt; arr.length; i++) {
    arr[i]
}

// 获取数组长度，注意 JavaScript 的数组长度是动态和可写的
arr.length // =&gt; 3
arr.length = 2 // arr =&gt; [10, 30]</code></pre>
<blockquote>
<p>除了使用<code>for</code>循环以外，也可以使用数组的<a href="#Array">相关方法</a>或者<a href="#for-of-循环">for of 循环</a>遍历数组。</p>
</blockquote>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>这里的对象指的是狭义的对象，它的本质是无序的键值对。</p>
<pre><code class="js">// 创建对象。注意，属性名的引号可选，
// 但如果属性名不符合标识符规则（如包含短横线、空格，或者以数字开头等），那么必须加引号
var person = { 
    name : &#39;Claire&#39;,
    age : 19,
    eat: function() { console.log(&#39;吃呀吃&#39;) }
}

// 访问对象属性，有 点运算符 和 方括号两种方式，后者可以传入变量，更加灵活，但嵌套太多不易阅读
person.age // =&gt; 19
person[&#39;age&#39;] // =&gt; 19

// 使用 for in 循环遍历对象，注意这是 ES5 语法，与 ES6 的 for of 区分开
for (var key in person) {
    key // 获取键
    person[key] // 获取值
}

// 判断对象中是否包含某个属性
&#39;name&#39; in person // =&gt; true</code></pre>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>JavaScript 中的函数以<code>Function</code>内置对象表示。</p>
<pre><code class="js">// 创建函数
function foo() {} // 函数声明
var foo = function() {} // 函数表达式

// 调用函数
foo()

// 传入参数，没有传入实参的参数为 undefined，多余的参数会被忽略
function foo(a, b) {
    a // =&gt; 10
    b // =&gt; undefined
}
foo(10)

// 函数内部使用 arguments 伪数组可以获取所有参数
function foo() {
    arguments[0] // =&gt; 10
    arguments[1] // =&gt; 20
    arguments.length // =&gt; 2
}
foo(10, 20)

// 返回值
// 函数遇到 return 会立刻终止运行。如果没有返回值，或者 return 后面没有内容，则返回 undefined
function getSum(a, b) { 
    return a + b 
}</code></pre>
<h4 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h4><p>如果函数可以存储在变量或数据结构中，并可以进行引用传递，那么称这样的函数为一等公民，表示它和其它类型享有同样的待遇。因此，JavaScript 中的函数可以直接赋值给一个变量，也可以作为函数的结果返回。也就是说，函数声明的名称本质就是一个<strong>保存了函数代码的变量</strong>。</p>
<pre><code class="js">function foo() { return &#39;我是一等公民啦!&#39; }
var other = foo
other() // =&gt; 我是一等公民啦! </code></pre>
<h4 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h4><p>JavaScript 会根据代码本行的开头是否为<code>function</code>来区分函数声明和函数表达式。因此，如果希望一个函数声明后立刻调用，而不是单独写一条调用语句，只需要让<code>function</code>不出现在行首，使引擎将其解析成一个表达式即可：</p>
<pre><code class="js">(function() { // 由于已经成为了表达式，函数名称可以省略
    console.log(&#39;S.H.E.I.L.D&#39;)
})()

// 或者
(function() {
    console.log(&#39;S.H.E.I.L.D&#39;)
}())</code></pre>
<p>这样引擎就会将其作为一个表达式来执行，它的最大作用是<strong>创建一个独自的作用域，避免命名发生冲突</strong>。</p>
<blockquote>
<p>如果采用了无分号的代码风格，那么立即执行函数的前面应当添加一个分号<code>;(function(){})()</code>，防止解析出错。</p>
</blockquote>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>作用域指的是变量所在的范围，它会把自己范围内的变量收集起来并统一管理。作用域分为两种（ES6 中还新增了块级作用域）：</p>
<ul>
<li>全局作用域：在整个运行过程中一直存在的作用域。JavaScript 会将一个页面中的全部<code>&lt;script&gt;</code>标签和单独的<code>.js</code>文件都合并成一个整体，因此即便是<strong>多个文件也是共享一个全局作用域</strong>。在全局作用域中声明的变量称为<strong>全局变量</strong>，在程序任何位置都可以访问。</li>
<li>局部作用域（函数作用域）：每声明一个函数，就会在<strong>函数内部</strong>创建一个新的局部作用域。在局部作用域中声明的变量称为<strong>局部变量</strong>，只能在该函数内部访问。此外，JavaScript 采用的为<strong>词法作用域</strong>，也就是说<strong>作用域由函数声明</strong>时的位置决定，与调用的位置无关。</li>
</ul>
<pre><code class="js">/* 全局作用域 */
var num = 10
console.log(num) // =&gt; 10

function foo() {
    /* 局部作用域 */
    var num = 20
    console.log(num) // =&gt; 20
}</code></pre>
<p>当函数发生嵌套时，其对应的局部作用域也会嵌套。因此作用域除了保存范围内的变量之外，还会<strong>保存外部的作用域</strong>。因此，在当前的作用域中无法找到某个变量时，就会在嵌套的上一级作用域中继续查找该变量，直到全局作用域为止。这一连串的作用域被称为<strong>作用域链</strong>。</p>
<pre><code class="js">/* 全局作用域 */
var num = 10

function outer() {
    /* outer 的局部作用域 */
    var num = 20

    function inner() {
        /* inner 的局部作用域 */
        console.log(num) // =&gt; 20，inner 作用域内没有 num 变量，因此去上一级 outer的作用域中找
    }
}</code></pre>
<h4 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h4><p>JavaScript 在所有代码执行前会首先收集所有<strong>变量声明</strong>和<strong>函数声明</strong>（不包括函数表达式），然后将它们提升到<strong>所在作用域</strong>的开头。例如：</p>
<pre><code class="js">console.log(a) // =&gt; undefined
var a = 2

// 等价于
var a
console.log(a)
a = 2</code></pre>
<p>函数声明也会被提升：</p>
<pre><code class="js">fun() // =&gt; 我被提升啦
function fun() { console.log(&#39;我被提升啦&#39;) }</code></pre>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>当内部函数通过作用域链访问了外部函数的变量，则称外部函数为一个闭包，通过 Chrome 设置断点可以查看：</p>
<pre><code class="js">function father() {
    var num = 1
    function son() { console.log(num) } // 访问了外部函数的 num 变量
    son()
}

father()</code></pre>
<p><img src="https://pic3.superbed.cn/item/5dfc573776085c32890afa0b.jpg" alt=""></p>
<p>不过这样的闭包并没有意义，它的最主要作用在于<strong>延长变量的生命周期</strong>。在下面的代码中，每次调用<code>father()</code>函数，<code>num</code>的值都是<code>1</code>，因为当调用结束后，<code>father()</code>的作用域就被销毁了。</p>
<pre><code class="js">function father() {
    var num = 1
    function son() { console.log(num++) }
    son()
}

father() // =&gt; 1
father() // =&gt; 1</code></pre>
<p>但是，如果将内部函数作为返回值，传递到外部，再由外部调用，结果就不一样了：</p>
<pre><code class="js">function father() {
    var num = 1
    function son() { console.log(num++) }
    return son
}

var fn = father()
fn() // =&gt; 1
fn() // =&gt; 2</code></pre>
<p>这是因为，虽然<code>father()</code>调用结束了，但是它其中的函数被传递到了外部，由于内部函数依然在使用，所以<code>father()</code>的作用域也被保存了下来。</p>
<blockquote>
<p>可以这么理解：我叫独孤求败（内部函数），我在一个山洞（闭包）里，里面有世界上最好的剑法和武器（内部变量）。我学习了里面的剑法，拿走了最好的剑，离开了这里（闭包返回了函数）。我来到这个江湖，快意恩仇，但是从来没有人知道我这把剑，和我这一身的武功的来历（外部无法访问闭包内部的变量，只有内部函数才可以）。</p>
</blockquote>
</div>
    </div>
</div>

<div class="toc"></div>
    <footer>
    <p>© 2020</p>
    <p>Theme chicken by 小鸡米花, Powered by Hexo</p>
</footer>
    <a class="back-to-top" href="javascript:;"></a>

    <script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
    <script defer src="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.js"></script>
    <script defer src="https://cdn.staticfile.org/KaTeX/0.11.1/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, { strict: false, delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}] });"></script>
    <script src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js"></script>
    <script src="https://cdn.staticfile.org/highlight.js/9.18.1/highlight.min.js"></script>

    <script>
        // 为标签追加字体图标
        $('.tag-list-item').prepend('<i class="fas fa-tag"></i>')

        // 回到顶部的猫
        $('.back-to-top').click(function () {
            $('html, body').animate({
                scrollTop: 0
            }, 500)
        })

        // 监听 回到顶部的猫 是否显示
        $(document).scroll(function () {
            if ($(document).scrollTop() > 50) {
                $('.back-to-top').addClass('show')
            } else {
                $('.back-to-top').removeClass('show')
            }
        })

        // 在表格外包裹一层，用来生成滚动条
        $('.post-content > table').wrap('<div class="table-container"></div>')

        // Tocbot 实例化，用来快速生成文档目录
        tocbot.init({
            tocSelector: '.toc', // 渲染目录的容器
            contentSelector: '.post-content', // 标题所在的容器
            headingSelector: 'h2, h3', // 要渲染的目录层级,
            headingsOffset: -50, // 微调目录高亮的显示位置（偏移量），防止点击的链接和高亮的链接不一致
        })

        // 初始化代码高亮 highlight.js
        hljs.initHighlightingOnLoad()

        // 自动加载 waifu
        try {
            $("<link>").attr({ href: "//cdn.yesuanzao.cn/blog/live2d/waifu.min.css", rel: "stylesheet", type: "text/css" }).appendTo('head');
            $('body').append('<div class="waifu"><div class="waifu-tips"></div><canvas id="live2d" class="live2d"></canvas><div class="waifu-tool"><span class="fui-home"></span> <span class="fui-chat"></span> <span class="fui-eye"></span> <span class="fui-user"></span> <span class="fui-photo"></span> <span class="fui-info-circle"></span> <span class="fui-cross"></span></div></div>');
            $.ajax({ url: '//cdn.yesuanzao.cn/blog/live2d/waifu-tips.js', dataType: "script", cache: true, async: false });
            $.ajax({ url: '//cdn.yesuanzao.cn/blog/live2d/live2d.min.js', dataType: "script", cache: true, async: false, success: function() {
                initModel('//cdn.yesuanzao.cn/blog/live2d/waifu-tips.json');
            } });
        } catch (err) { console.log(err) }
    </script>
    <!-- 
        添加控制台，测试移动端
        <script src="http://cdn.jsdelivr.net/npm/eruda"></script>
        <script>eruda.init();</script>
    -->
</body>

</html>