<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>这是一个神奇的主题</title>
    <link rel="stylesheet" href="//cdn.yesuanzao.cn/blog/chicken.css">
    <link rel="stylesheet" href="/css/iconfont.css">
    <link rel="stylesheet" href="//cdn.yesuanzao.cn/blog/atom-one-dark.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css">
<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <header>
    <div class="container">
        <div class="site-title"><a href="/">小鸡米花的知识库</a></div>
        <nav>
            <a class="nav-item " href="/">主页</a>
            <a class="nav-item " href="/archives">时光轴</a>
        </nav>
    </div>
</header>
    <div id="write">
    <div class="container">
        <div class="post-info">
            <ul class="tag-list">
                
                    <a class="tag-list-item" href="/tags/JavaScript/">JavaScript</a>
                
            </ul>
        </div>
        <div class="post-content"><h1 id="大前端支线笔记之07-⚽️-AJAX"><a href="#大前端支线笔记之07-⚽️-AJAX" class="headerlink" title="大前端支线笔记之07 ⚽️ AJAX"></a>大前端支线笔记之07 ⚽️ AJAX</h1><p>在传统的 Web 应用中，当用户提交表单时，需要向服务端发送一个请求，服务端处理完收到的表单后，再将一个新的网页响应回来。但是这样的做法有些缺点：首先，填写表单的页面和返回的页面大部分内容都是相同的，浪费了传输的带宽；其次，对于用户来说，提交表单之后需要等待页面重新加载，体验并不友好。</p>
<p>为了解决这些问题，有人提出了 AJAX 这一概念。AJAX（Asynchronous Javascript And XML）指的是异步加载 JavaScript 和 XML，也就是使浏览器异步地向服务器发送请求，以获得新的数据，再通过操作 DOM 实现在不刷新页面的情况下展示新的内容。</p>
<p>这一技术目前已被 JavaScript 正式引入，它通常应用在如页面滚动加载数据、局部更新、实时验证用户表单、搜索框信息提示等多种场景。</p>
<blockquote>
<p>AJAX 名称中之所以包含 XML 是因为早期的互联网信息传输中主要以 XML 为内容格式，但是目前 XML 基本已被 JSON 取代。按道理说，这个名称现在也可以改为 AJAJ，但是由于已经大家习惯了 AJAX，因此它暂时还是被保留了下来。</p>
</blockquote>
<h2 id="原生-AJAX"><a href="#原生-AJAX" class="headerlink" title="原生 AJAX"></a>原生 AJAX</h2><p>JavaScript 通过<code>XMLHttpRequest</code>对象提供对 Ajax 的支持，因此需要先实例化该对象。</p>
<pre><code class="js">var xhr = new XMLHttpRequest()</code></pre>
<p>然后使用该对象的<code>open()</code>方法可以初始化一个请求，建立与服务端的连接。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>请求方式</td>
</tr>
<tr>
<td>字符串</td>
<td>请求 URL</td>
</tr>
</tbody></table>
<pre><code class="js">xhr.open(&#39;GET&#39;, &#39;http://localhost/test&#39;)</code></pre>
<p>接下来，使用该对象的<code>send()</code>方法发送请求。</p>
<pre><code class="js">xhr.send()</code></pre>
<p>如果要传递<code>GET</code>请求参数，将其拼接到 URL 一并发送即可。</p>
<p>如果要传递<code>POST</code>请求参数，需要先了解请求体的几种类型，通过表单提交数据时，该类型通过<code>enctype</code>属性设置，否则的话，需要手动设置请求头中的<code>Content-Type</code>属性：</p>
<ul>
<li><code>application/x-www-form-urlencoded</code>：表单<code>POST</code>提交方式的默认类型，如<code>name=lucy&amp;age=18</code></li>
<li><code>multipart/form-data</code>：二进制类型，上传文件时经常使用</li>
<li><code>application/json</code>：JSON 格式数据，不支持表单提交，如<code>{&quot;name&quot;: &quot;lucy&quot;, &quot;age&quot;: 18}</code></li>
</ul>
<p>然后通过<code>setRequestHeader()</code>设置请求体类型：</p>
<pre><code class="js">xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;)</code></pre>
<p>最后将数据放到<code>send()</code>方法中即可：</p>
<pre><code class="js">xhr.send(&#39;name=lucy&amp;age=18&#39;)</code></pre>
<h2 id="接收响应"><a href="#接收响应" class="headerlink" title="接收响应"></a>接收响应</h2><p>由于 Ajax 请求是异步操作，因此当请求发送成功后会触发<code>load</code>事件，此时通过请求对象的<code>responseText</code>属性可以获取服务器响应的结果。</p>
<pre><code class="js">xhr.addEventListener(&#39;load&#39;, function() {
    this.responseText // =&gt; ok
})</code></pre>
<h3 id="低版本浏览器"><a href="#低版本浏览器" class="headerlink" title="低版本浏览器"></a>低版本浏览器</h3><p>低版本浏览器并不支持<code>load</code>事件，因此需要通过监听 Ajax 的状态来实现接收响应。当 Ajax 的状态发生变化时，会触发<code>onreadystatechange</code>事件，而当前的状态通过<code>readyState</code>属性来保存，它共有 5 个数字值，分别为：</p>
<ul>
<li><code>0</code>：<code>open()</code>方法还未被调用</li>
<li><code>1</code>：<code>open()</code>方法已经被调用</li>
<li><code>2</code>：<code>send()</code>方法已经被调用，并且获取了响应头的信息</li>
<li><code>3</code>：<code>responseText</code>已经获取了部分响应体的数据</li>
<li><code>4</code>：整个请求过程完毕</li>
</ul>
<p>也就是说，当<code>readyState</code>属性为<code>4</code>时，才可以通过<code>responseText</code>属性获取响应体的数据和其它响应报文信息。</p>
<pre><code class="js">xhr.addEventListener(&#39;readystatechange&#39;, function() {
    if (this.readyState == 4) {
        this.responseText // 获取响应体的数据
        this.status // =&gt; 200，HTTP 状态码
        this.statusText // =&gt; OK，HTTP 状态信息
    }
})</code></pre>
<h2 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h2><p>通过<code>FormData</code>对象可以模拟一个表单，并通过 Ajax 将其提交到服务器。首先通过表单元素实例化一个<code>FormData</code>对象，使用 Ajax 将<code>FormData</code>对象发送到服务器。</p>
<pre><code class="html">&lt;form id=&quot;myform&quot;&gt;
    &lt;input type=&quot;text&quot; id=&quot;username&quot; name=&quot;username&quot; value=&quot;hello&quot;&gt;
    &lt;input type=&quot;text&quot; id=&quot;age&quot; name=&quot;age&quot; value=&quot;18&quot;&gt;
    &lt;button type=&quot;button&quot; id=&quot;submit&quot;&gt;提交&lt;/button&gt;
&lt;/form&gt;</code></pre>
<pre><code class="js">$(&#39;#submit&#39;).click(function () {
    var formData = new FormData($(&#39;#myform&#39;)[0])

    var xhr = new XMLHttpRequest()
    xhr.open(&#39;POST&#39;, &#39;http://localhost/&#39;)
    xhr.send(formData)
})</code></pre>
<h3 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h3><p>此外，它还包括下列的常用方法。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>get()</code></td>
<td>获取表单属性的值</td>
</tr>
<tr>
<td><code>set()</code></td>
<td>设置表单属性的值，如果存在同名属性，则覆盖该属性值；如果不存在则会自动创建</td>
</tr>
<tr>
<td><code>delete()</code></td>
<td>删除表单属性</td>
</tr>
<tr>
<td><code>append()</code></td>
<td>添加表单属性</td>
</tr>
</tbody></table>
<pre><code class="js">formData.get(&#39;age&#39;) // =&gt; 18
formData.set(&#39;age&#39;, 19) // =&gt; { username: &#39;hello&#39;, age: &#39;19&#39; }
formData.delete(&#39;age&#39;) // =&gt; { username: &#39;hello&#39; }
formData.append(&#39;sex&#39;, &#39;male&#39;) // =&gt; { username: &#39;hello&#39;, age: &#39;19&#39;, sex: &#39;male&#39; }</code></pre>
<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源策略是浏览器的一种安全策略，所谓同源指的是两个地址之间的<strong>域名</strong>、<strong>协议</strong>和<strong>端口号</strong>完全相同，只要有其中一项不同，那么这两个地址就是不同源的。只有同源的地址之间才能互相发送 Ajax 请求，不同源之间的相互请求被称为<strong>跨域</strong>。</p>
<p>在下面的请求中，从<code>http://localhost</code>向<code>http://test.io</code>发送请求，浏览器会出现报错信息。</p>
<pre><code class="js">xhr.open(&#39;GET&#39;, &#39;http://test.io&#39;)
xhr.send()</code></pre>
<p><img src="https://ae01.alicdn.com/kf/H6c61e102852f4ae69db13ab91bba9ee2n.jpg" alt=""></p>
<h3 id="跨域资源共享（☢️IE10）"><a href="#跨域资源共享（☢️IE10）" class="headerlink" title="跨域资源共享（☢️IE10）"></a>跨域资源共享（☢️IE10）</h3><p>从上面的报错信息中可以看到，请求被 CORS 策略阻止了，它指的是跨域资源共享（Cross-origin resource sharing）。而后面提示中指出，在响应头信息中没有找到<code>Access-Control-Allow-Origin</code>字段，也就是说，如果服务端希望接收来自其它域的 Ajax 请求，只需要添加一条响应头信息即可：</p>
<pre><code class="js">// 通过中间件拦截所有请求
app.use((req, res) =&gt; {
    // * 表示对任何请求地址均采用 CORS，如果指定了域名，那么只有来自该域名的请求能正确接收
    res.header(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;)
    next()
})</code></pre>
<blockquote>
<p>在跨域资源共享出现之前，是通过 JSONP 来实现这一功能的，但是由于代码比较复杂，不再赘述，直接使用 jQuery 中的 JSONP 即可。</p>
<p>此外，由于服务端没有同源策略限制，可以先由客户端请求同源的服务器，由服务器再发送跨域请求，获取到数据后再返回给客户端。</p>
</blockquote>
<h3 id="跨域携带-Cookie"><a href="#跨域携带-Cookie" class="headerlink" title="跨域携带 Cookie"></a>跨域携带 Cookie</h3><p>默认情况下，跨域请求是不会携带客户端 Cookie 的。要修改这一点，需要客户端和服务端同时进行设置。</p>
<pre><code class="js">// 客户端
xhr.open(&#39;GET&#39;, &#39;http://test.io&#39;)
xhr.withCredentials = true // 设置跨域时携带 Cookie
xhr.send()</code></pre>
<pre><code class="js">// 服务端
res.header(&#39;Access-Control-Allow-Credentials&#39;, true) // 响应头也要同时设置</code></pre>
<h2 id="ajax"><a href="#ajax" class="headerlink" title="$.ajax()"></a>$.ajax()</h2><p>发送 Ajax 请求。它的参数为一个对象，其中包含若干配置属性：</p>
<pre><code class="js">$.ajax({
    url: &#39;/add&#39;, // 请求地址
    type: &#39;post&#39;, // 请求类型
    data: { name: &#39;离散懵逼&#39;, age: 38 }, // 传递给服务器的参数，会被自动转换成 urlencode 格式
    // 设置为 dataType: &#39;jsonp&#39; 表示发送 JSONP 请求
    dataType: &#39;json&#39;, // 要求响应体的数据必须为 JSON 格式，默认为根据响应头的 content-type 自动识别

    beforeSend: function() { // 请求发送前的回调函数，可以用来验证数据或者显示 Loading 动画
        return false // 如果返回 false 则取消发送当前请求
    },
    // 根据状态码（是否为 200）判断请求状态
    success: function (res) {}, // res 为服务端返回的响应体内容，会根据 dataType 自动完成转换
    error: function (xhr) {}, // xhr 为原生的 XMLHttpRequest 对象
})</code></pre>
<h2 id="serialize"><a href="#serialize" class="headerlink" title="serialize()"></a>serialize()</h2><p>将表单控件中的值转换成 URLencoded 格式的字符串。</p>
<pre><code class="js">$(&#39;form&#39;).serialize() // =&gt; name=Lucy&amp;age=18</code></pre>
<p>如果要直接转换成对象，可以使用 jQuery 的第三方插件<a href="https://github.com/marioizquierdo/jquery.serializeJSON" target="_blank" rel="noopener">serializeJSON</a>。</p>
<h2 id="dollar-get-dollar-post"><a href="#dollar-get-dollar-post" class="headerlink" title="&dollar;.get() / &dollar;.post()"></a>&dollar;.get() / &dollar;.post()</h2><p>快速发送 GET / POST 请求。</p>
<pre><code class="js">$.get(&#39;/add&#39;, { age: 18 }, function(res) {})</code></pre>
<h2 id="dollar-ajaxStart-dollar-ajaxComplete"><a href="#dollar-ajaxStart-dollar-ajaxComplete" class="headerlink" title="&dollar;.ajaxStart() / &dollar;.ajaxComplete()"></a>&dollar;.ajaxStart() / &dollar;.ajaxComplete()</h2><p>统一设置 Ajax 请求发送之前 / 之后的回调函数，该事件只能绑定到<code>document</code>对象上。</p>
<pre><code class="js">$(document).ajaxStart(function () {
    // 请求即将发送
})</code></pre>
<h2 id="load"><a href="#load" class="headerlink" title="load()"></a>load()</h2><p>在 Ajax 请求成功并获取返回数据后，自动调用<code>html()</code>将数据插入到匹配的元素中。</p>
<pre><code class="js">$(&#39;div&#39;).load(&#39;backend/test.php&#39;, { key: &#39;value&#39;}, function(res) {});</code></pre>
<p>如果请求返回的是一个页面，还可以在 URL 参数后面添加一个空格，然后追加选择器，来获取更加具体的内容。</p>
<pre><code class="js">$(&#39;#div-elem&#39;).load(&#39;test.php #banner&#39;);</code></pre>
</div>
    </div>
</div>

<div class="toc"></div>
    <footer>
    <p>© 2020</p>
    <p>Theme chicken by 小鸡米花, Powered by Hexo</p>
</footer>
    <a class="back-to-top" href="javascript:;"></a>

    <script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
    <script defer src="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.js"></script>
    <script defer src="https://cdn.staticfile.org/KaTeX/0.11.1/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, { strict: false, delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}] });"></script>
    <script src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js"></script>
    <script src="https://cdn.staticfile.org/highlight.js/9.18.1/highlight.min.js"></script>
    <script src="http://cdn.yesuanzao.cn/blog/live2d/autoload.js" type="text/javascript"></script>
    <script src="http://cdn.yesuanzao.cn/blog/chicken.js"></script>
    <!-- 
        添加控制台，测试移动端
        <script src="http://cdn.jsdelivr.net/npm/eruda"></script>
        <script>eruda.init();</script>
    -->
</body>

</html>