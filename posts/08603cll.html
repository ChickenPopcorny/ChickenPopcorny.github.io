<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>这是一个神奇的主题</title>
    <link rel="stylesheet" href="/css/chicken.css">
    <link rel="stylesheet" href="/css/iconfont.css">
    <link rel="stylesheet" href="/css/atom-one-dark.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
        integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css">
<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <header>
    <div class="container">
        <div class="site-title"><a href="/">小鸡米花的知识库</a></div>
        <nav>
            <a class="nav-item " href="/">主页</a>
            <a class="nav-item " href="/archives">时光轴</a>
        </nav>
    </div>
</header>
    <div id="write">
    <div class="container">
        <div class="post-info">
            <ul class="tag-list">
                
                    <a class="tag-list-item" href="/tags/CSS/">CSS</a>
                
            </ul>
        </div>
        <div class="post-content"><h1 id="大前端笔记之05-📦-CSS-盒模型"><a href="#大前端笔记之05-📦-CSS-盒模型" class="headerlink" title="大前端笔记之05 📦 CSS 盒模型"></a>大前端笔记之05 📦 CSS 盒模型</h1><p>每个元素都会生成一个矩形的元素盒子，从外到内依次为外边距、边框、内边距和内容区。</p>
<h2 id="外边距"><a href="#外边距" class="headerlink" title="外边距"></a>外边距</h2><p>使用<code>margin</code>设置元素的外边距，即元素之间的距离。该属性是<code>margin-top</code>、<code>margin-right</code>、<code>margin-bottom</code>和<code>margin-left</code>四个属性的简写属性。可以单独使用它们设置某个方向的外边距，或者使用<code>margin</code>同时设置不同的方向。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>所有元素</td>
<td>不可继承</td>
<td><code>0</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code></td>
<td>见<a href="/posts/vv37590w.html">包含块</a>一节</td>
</tr>
<tr>
<td>长度值</td>
<td>设置具体的外边距</td>
</tr>
</tbody></table>
<p>该属性根据数量不同分别表示不同的方向：</p>
<table>
<thead>
<tr>
<th>值的数量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>4</td>
<td>分别对应「上，右，下，左」</td>
</tr>
<tr>
<td>3</td>
<td>分别对应「上，左右，下」</td>
</tr>
<tr>
<td>2</td>
<td>分别对应「上下，左右」</td>
</tr>
<tr>
<td>1</td>
<td>同时设置四个方向</td>
</tr>
</tbody></table>
<h3 id="外边距合并"><a href="#外边距合并" class="headerlink" title="外边距合并"></a>外边距合并</h3><p>如果同一个<a href="/posts/9obo9xpo.html">BFC</a>中的上下外边距紧挨在一起的话，那么会产生合并的现象，相当于它们共同拥有一个外边距。</p>
<p>合并的规则如下：如果都是正值，则保留较大的一个；如果是一正一负，则保留它们的和；如果都是负值，则保留绝对值较大的一个。</p>
<pre><code class="css">div:first-child { /* 上面的 &lt;div&gt; */
    margin-bottom: 50px;
}
div:last-child { /* 下面的 &lt;div&gt; */
    margin-top: 30px;
}
/* 它们实际的距离为 50px */</code></pre>
<p>另外，父元素和子元素在<strong>上方</strong>的外边距也会发生合并，合并规则同上，但是合并后的外边距会交给<strong>父元素</strong>来表现。</p>
<p>在下面的代码中，一个<code>&lt;div&gt;</code>元素中包含一个子元素<code>&lt;p&gt;</code>，此时<code>&lt;div&gt;</code>不会出现在浏览器最顶端，而是被子元素的<code>margin-top</code>连带着一起向下移动了<code>100px</code>，父子元素之间则没有任何距离。</p>
<pre><code class="css">div { height: 400px; }
p { height: 200px; margin-top: 100px; }</code></pre>
<p>使用下面的方法可以避免这种情况：</p>
<ul>
<li>父元素触发<a href="/posts/9obo9xpo.html">BFC</a></li>
<li>父元素对应方向的<code>border</code>或<code>padding</code>不为<code>0</code></li>
<li>父子元素之间有行内元素分隔</li>
</ul>
<h2 id="内边距"><a href="#内边距" class="headerlink" title="内边距"></a>内边距</h2><p>使用<code>padding</code>设置元素的内边距，即元素内容与边框之间的距离。该属性是<code>padding-top</code>、<code>padding-right</code>、<code>padding-bottom</code>和<code>padding-left</code>四个属性的简写属性。可以单独使用它们设置某个方向的内边距，或者使用<code>padding</code>同时设置不同的方向。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>所有元素</td>
<td>不可继承</td>
<td><code>0</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>长度值</td>
<td>设置具体的内边距</td>
</tr>
</tbody></table>
<p>该属性根据数量不同分别表示不同的方向：</p>
<table>
<thead>
<tr>
<th>值的数量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>4</td>
<td>分别对应「上，右，下，左」</td>
</tr>
<tr>
<td>3</td>
<td>分别对应「上，左右，下」</td>
</tr>
<tr>
<td>2</td>
<td>分别对应「上下，左右」</td>
</tr>
<tr>
<td>1</td>
<td>同时设置四个方向</td>
</tr>
</tbody></table>
<h2 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h2><p>使用<code>border</code>设置元素的边框。该属性是<code>border-width</code>、<code>border-style</code>和<code>border-color</code>三个属性的简写属性，顺序没有要求。</p>
<h3 id="边框宽度"><a href="#边框宽度" class="headerlink" title="边框宽度"></a>边框宽度</h3><p>使用<code>border-width</code>设置边框的宽度，该属性是<code>border-top-width</code>、<code>border-right-width</code>、<code>border-bottom-width</code>和<code>border-left-width</code>四个属性的简写属性。可以单独使用它们设置某个方向的边框宽度，或者使用<code>border-width</code>同时设置不同的方向。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>所有元素</td>
<td>不可继承</td>
<td><code>medium</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>medium</code></td>
<td>浏览器自定义</td>
</tr>
<tr>
<td>长度值</td>
<td>设置具体的边框宽度</td>
</tr>
</tbody></table>
<p>该属性根据数量不同分别表示不同的方向：</p>
<table>
<thead>
<tr>
<th>值的数量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>4</td>
<td>分别对应「上，右，下，左」</td>
</tr>
<tr>
<td>3</td>
<td>分别对应「上，左右，下」</td>
</tr>
<tr>
<td>2</td>
<td>分别对应「上下，左右」</td>
</tr>
<tr>
<td>1</td>
<td>同时设置四个方向</td>
</tr>
</tbody></table>
<h3 id="边框样式"><a href="#边框样式" class="headerlink" title="边框样式"></a>边框样式</h3><p>通过<code>border-style</code>可以设置边框的样式，该属性是<code>border-top-style</code>、<code>border-right-style</code>、<code>border-bottom-style</code>和<code>border-left-style</code>四个属性的简写属性。可以单独使用它们设置某个方向的边框样式，或者使用<code>border-style</code>同时设置不同的方向。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>所有元素</td>
<td>不可继承</td>
<td><code>none</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code></td>
<td>无边框样式，由于该值是默认值，因此<strong>如果没有这个属性，边框就不会存在</strong></td>
</tr>
<tr>
<td><code>solid</code></td>
<td>实线</td>
</tr>
<tr>
<td><code>dotted</code></td>
<td>点线</td>
</tr>
<tr>
<td><code>dashed</code></td>
<td>破折线</td>
</tr>
</tbody></table>
<p>该属性根据数量不同分别表示不同的方向：</p>
<table>
<thead>
<tr>
<th>值的数量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>4</td>
<td>分别对应「上，右，下，左」</td>
</tr>
<tr>
<td>3</td>
<td>分别对应「上，左右，下」</td>
</tr>
<tr>
<td>2</td>
<td>分别对应「上下，左右」</td>
</tr>
<tr>
<td>1</td>
<td>同时设置四个方向</td>
</tr>
</tbody></table>
<h3 id="边框颜色"><a href="#边框颜色" class="headerlink" title="边框颜色"></a>边框颜色</h3><p>使用<code>border-color</code>设置边框的颜色，该属性是<code>border-top-color</code>、<code>border-right-color</code>、<code>border-bottom-color</code>和<code>border-left-color</code>四个属性的简写属性。可以单独使用它们设置某个方向的边框颜色，或者使用<code>border-color</code>同时设置不同的方向。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>所有元素</td>
<td>不可继承</td>
<td>当前元素的<code>color</code>属性值</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>颜色值</td>
<td>任何合法的颜色值</td>
</tr>
</tbody></table>
<p>该属性根据数量不同分别表示不同的方向：</p>
<table>
<thead>
<tr>
<th>值的数量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>4</td>
<td>分别对应「上，右，下，左」</td>
</tr>
<tr>
<td>3</td>
<td>分别对应「上，左右，下」</td>
</tr>
<tr>
<td>2</td>
<td>分别对应「上下，左右」</td>
</tr>
<tr>
<td>1</td>
<td>同时设置四个方向</td>
</tr>
</tbody></table>
<h3 id="边框方向"><a href="#边框方向" class="headerlink" title="边框方向"></a>边框方向</h3><p>除上述方式之外，还可以使用<code>border-top</code>、<code>border-bottom</code>、<code>border-left</code>和<code>border-right</code>来简写对应方向的<strong>宽度、样式和颜色</strong>值。这些属性要求值的顺序严格，但是可以省略其中的任意值。</p>
<pre><code class="css">div { border-top: 1px solid #ccc; }</code></pre>
<h3 id="边框圆角"><a href="#边框圆角" class="headerlink" title="边框圆角"></a>边框圆角</h3><p>使用<code>border-radius</code>设置边框圆角。注意，该属性不会改变元素盒子实际的形状。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>所有元素</td>
<td>不可继承</td>
<td><code>0</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>长度值</td>
<td>设置具体的圆角大小</td>
</tr>
<tr>
<td>百分比值</td>
<td>相对于对应方向的<code>border</code>长度</td>
</tr>
</tbody></table>
<p>该属性根据数量不同分别表示不同的方向：</p>
<table>
<thead>
<tr>
<th>值的数量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>4</td>
<td>分别对应「左上，右上，右下，左下」</td>
</tr>
<tr>
<td>3</td>
<td>分别对应「左上，右上左下，右下」</td>
</tr>
<tr>
<td>2</td>
<td>分别对应「左上右下，右上左下」</td>
</tr>
<tr>
<td>1</td>
<td>同时设置四个方向</td>
</tr>
</tbody></table>
<p>圆角的大小本质是一个圆或者椭圆的半径，使用它的四分之一来定义边框的弧度。比如：</p>
<pre><code class="css">div { border-radius: 10px; }</code></pre>
<p><img src="https://pic1.superbed.cn/item/5dfb269376085c3289c4d1f7.jpg" alt=""></p>
<h3 id="边框图片"><a href="#边框图片" class="headerlink" title="边框图片"></a>边框图片</h3><p>边框图片用于设置更复杂的边框。注意，必须将<code>border-style</code>设置成一个不为<code>none</code>的值，否则边框图片无法显示。</p>
<h4 id="图片路径"><a href="#图片路径" class="headerlink" title="图片路径"></a>图片路径</h4><p>使用<code>border-image-source</code>设置图片的路径，不能省略。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>所有元素</td>
<td>不可继承</td>
<td><code>none</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code></td>
<td>没有边框图片</td>
</tr>
<tr>
<td><code>url()</code></td>
<td>图片的 URL</td>
</tr>
</tbody></table>
<h4 id="裁切位置"><a href="#裁切位置" class="headerlink" title="裁切位置"></a>裁切位置</h4><p>使用<code>border-image-slice</code>设置图片的裁切位置。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>所有元素</td>
<td>不可继承</td>
<td><code>100%</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数字值</td>
<td><strong>不能加单位</strong>，默认为像素</td>
</tr>
<tr>
<td>百分比值</td>
<td>相对于图片的宽高</td>
</tr>
</tbody></table>
<p>该属性根据数量不同分别表示不同的方向：</p>
<table>
<thead>
<tr>
<th>值的数量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>4</td>
<td>分别对应「上，右，下，左」</td>
</tr>
<tr>
<td>3</td>
<td>分别对应「上，左右，下」</td>
</tr>
<tr>
<td>2</td>
<td>分别对应「上下，左右」</td>
</tr>
<tr>
<td>1</td>
<td>同时设置四个方向</td>
</tr>
</tbody></table>
<p>该属性的作用原理是，浏览器会在边框图片上放置 4 条切割线，每条线到图片边缘的距离就是<code>border-image-slice</code>的值。</p>
<p>例如，背景图片为<code>500 × 500</code>大小，那么将 4 个值设置为<code>167</code>或<code>33.3%</code>正好可以将其等分为 9 份，从而形成一个九宫格。</p>
<pre><code class="css">div {
    border-image-slice: 167; /* 左图 */
    border-image-slice: 10% 20% 30% 50%; /* 右图 */
}</code></pre>
<p><img src="https://pic2.superbed.cn/item/5dfb28a176085c3289c531d2.jpg" alt=""></p>
<p>然后，九宫格的四个角会分别作为边框的四角，而上下左右四个部分会作为边框的四边，按照一定的方式平铺：</p>
<p><img src="https://pic.superbed.cn/item/5dfb28c576085c3289c537f1.jpg" alt=""></p>
<p>因此，如果将 4 个值全部设置为<code>50%</code>，那么图片只能被等分为 4 份，只有 4 个角才有图案，分别为图片的四分之一；如果将 4 个值全部设置为<code>100%</code>，那么图片只有 1 份，该图片会被完整的显示在 4 个角上，四边依然没有图案。</p>
<p><img src="https://pic.superbed.cn/item/5dfb28ec76085c3289c542d1.jpg" alt=""></p>
<h4 id="边的平铺方式"><a href="#边的平铺方式" class="headerlink" title="边的平铺方式"></a>边的平铺方式</h4><p>使用<code>border-image-repeat</code>设置四边的平铺方式。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>所有元素</td>
<td>不可继承</td>
<td><code>stretch</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>stretch</code></td>
<td>拉伸</td>
</tr>
<tr>
<td><code>repeat</code></td>
<td>将边框图片放在边框的中央，然后向两侧重复，边缘的部分可能会被截断</td>
</tr>
<tr>
<td><code>round</code></td>
<td>改变边框图片的尺寸，使其正好放置在边框之内</td>
</tr>
</tbody></table>
<p><img src="https://pic.superbed.cn/item/5dfb294976085c3289c55bdc.jpg" alt=""></p>
<h4 id="边框图片宽度"><a href="#边框图片宽度" class="headerlink" title="边框图片宽度"></a>边框图片宽度</h4><p>使用<code>border-image-width</code>设置边框图片的宽度。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>所有元素</td>
<td>不可继承</td>
<td><code>1</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数字值</td>
<td>表示<code>border-width</code>的倍数</td>
</tr>
<tr>
<td>长度值</td>
<td>设置具体的边框图片宽度</td>
</tr>
</tbody></table>
<p>该属性的原理与<code>border-image-slice</code>相似，区别在于<code>border-image-width</code>是在元素（边框区域）上绘制 4 条切割线，然后将切割出来的部分作为边框图片的绘制区域。</p>
<p><img src="https://pic3.superbed.cn/item/5dfb296776085c3289c561f4.jpg" alt=""></p>
<p>上面的两个元素均设置了<code>30px</code>的<code>border-width</code>、<code>200px</code>的宽高，区别在于左图单独设置了<code>20px</code>的<code>border-image-width</code>。可见默认情况下，边框图片绘制在<strong>元素的内部</strong>，不会导致元素扩大。而且，虽然图片边框没有实际边框大，但是<strong>只要是图片边框存在，那么实际边框就不会显示，就好像是透明了一样（因为大小还在）</strong>，因此被元素的背景色填充。</p>
<blockquote>
<p>按照《CSS 权威指南》中的说法，<code>border-width</code>不会影响边框图片的显示，只会影响元素的大小。但是在 Chrome 下，如果没有设置<code>border-width</code>，那么 Chrome 会默认为其添加<code>3px</code>的大小。如果直接将其设置为<code>0</code>，那么边框图片会<strong>无法显示</strong>。</p>
</blockquote>
<h4 id="绘制位置"><a href="#绘制位置" class="headerlink" title="绘制位置"></a>绘制位置</h4><p>默认情况下，边框图片绘制在元素的内部，不会导致元素扩大。使用<code>border-image-outset</code>属性可以设置边框图片向元素外推移。注意，该属性可能会导致边框图片与其它元素重叠，或者被浏览器边界截断。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>所有元素</td>
<td>不可继承</td>
<td><code>0</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数字值</td>
<td>表示<code>border-width</code>的倍数</td>
</tr>
<tr>
<td>长度值</td>
<td>设置具体向外推移的距离</td>
</tr>
</tbody></table>
<p><img src="https://pic3.superbed.cn/item/5dfb298176085c3289c569b1.jpg" alt=""></p>
<h4 id="简写属性"><a href="#简写属性" class="headerlink" title="简写属性"></a>简写属性</h4><p>使用<code>border-image</code>可以简写上述所有属性，其中图片路径<code>border-image-source</code>和平铺方式<code>border-image-repeat</code>可以写在任意位置，但是<code>border-image-slice</code>、<code>border-image-width</code>和<code>border-image-outset</code>必须按照顺序写在一起，并使用<code>/</code>分隔。其中除了图片路径外，其它的值都可以省略。</p>
<pre><code class="css">div { border-image: url(&quot;a.jpg&quot;) 33.3% / 20px / 30px round; }</code></pre>
<h2 id="宽高"><a href="#宽高" class="headerlink" title="宽高"></a>宽高</h2><p>使用<code>width</code>可以设置元素<strong>内容区（默认）</strong>的宽度。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>块级元素和行内替换元素</td>
<td>不可继承</td>
<td><code>auto</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code></td>
<td>见<a href="/posts/vv37590w.html">包含块</a>一节</td>
</tr>
<tr>
<td>长度值</td>
<td>设置具体的宽度</td>
</tr>
<tr>
<td>百分比值</td>
<td>相对于<a href="/posts/vv37590w.html">包含块</a>的<code>width</code></td>
</tr>
</tbody></table>
<p>使用<code>height</code>设置元素<strong>内容区（默认）</strong>的高度。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>块级元素和行内替换元素</td>
<td>不可继承</td>
<td><code>auto</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code></td>
<td>表示高度正好容纳它的子元素</td>
</tr>
<tr>
<td>长度值</td>
<td>设置具体的高度</td>
</tr>
<tr>
<td>百分比值</td>
<td>相对于<a href="/posts/vv37590w.html">包含块</a>的<code>height</code>，如果包含块没有一个<strong>具体</strong>的<code>height</code>，则相当于设置为<code>auto</code></td>
</tr>
</tbody></table>
<h3 id="修改作用区域"><a href="#修改作用区域" class="headerlink" title="修改作用区域"></a>修改作用区域</h3><p>使用<code>box-sizing</code>改变宽高的作用区域。默认情况下，<code>width</code>和<code>height</code>作用于内容区，添加额外的内边距或边框会导致元素实际会大于设置的<code>width</code>或<code>height</code>。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>块级元素和行内替换元素</td>
<td>不可继承</td>
<td><code>content-box</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>content-box</code></td>
<td>表示宽高作用于内容区</td>
</tr>
<tr>
<td><code>border-box</code></td>
<td>表示宽高作用于边框区域</td>
</tr>
</tbody></table>
<h3 id="最大-最小宽高"><a href="#最大-最小宽高" class="headerlink" title="最大 / 最小宽高"></a>最大 / 最小宽高</h3><p>使用<code>min-width</code>、<code>max-width</code>、<code>min-height</code>和<code>max-height</code>四个属性可以限制元素的宽度和高度，它们的用法与<code>width</code>和<code>height</code>基本一致。</p>
<h2 id="轮廓"><a href="#轮廓" class="headerlink" title="轮廓"></a>轮廓</h2><p>使用<code>outline</code>设置元素的轮廓。它显示在边框和外边距之间，但是<strong>不占据任何空间</strong>。而且，轮廓<strong>没有简写属性</strong>，因此只能将四个方向的轮廓设置为同一个样式或者不设置。</p>
<p>将文本框设置为<code>outline: none</code>可以清除其默认的蓝色轮廓效果。</p>
<h2 id="行内盒模型"><a href="#行内盒模型" class="headerlink" title="行内盒模型"></a>行内盒模型</h2><p>对于行内元素来说，它们在普通盒模型中的内容区比块级元素更加复杂。</p>
<p>首先，设计师在 EM Square 中设计出每个字符，不同字体的字符在 EM Square 中的位置可能会有所不同（例如微软雅黑会偏下），有些装饰笔画甚至会超出 EM Square 。多个字符的 EM Square 排列在一起会构成行内盒模型的<strong>内容区</strong>（与普通盒模型中内容区没关系），使用<code>font-size</code>可以控制它的高度。</p>
<p>然后，每个内容区外会包裹一个<strong>行内盒子</strong>，使用<code>line-height</code>可以控制它的高度，默认情况下内容区和行内盒子的高度应该是一样的。而且，只有<code>line-height</code>才能控制行内盒子的实际高度，如果行内盒子高度小于内容区，那么虽然内容可以正常显示，但是上下两行会重叠在一起。</p>
<p>但是，由于有些字体的个别部分可能会超出内容区，因此浏览器为了使行内盒子能容纳下每个字符而不至于发生重叠，通常默认将行内盒子的高度也就是<code>line-height</code>的值设置的比内容区稍大一点，通常为<code>1.2</code>，即内容区高度的<code>1.2</code>倍。因此，行内盒子和内容区之间会产生一定的距离，称为<strong>行间距</strong>。然后浏览器会将行间距等分成两份，分别在内容区的上下各添加一份。由于行间距是等分的，因此<strong>内容区总是在行内盒子的中间位置</strong>，通过这个特性，可以实现单行文本的垂直居中。</p>
<p><img src="https://pic.superbed.cn/item/5dfa9dfa76085c3289ae2e89.png" alt=""></p>
<p>最后，一行中的所有行内盒子又会被一个更大的盒子包裹，称为<strong>行框</strong>。行框的高度由其内部所有的行内盒子决定，浏览器会计算每个行内盒子的高度，并且采用它们的<strong>最高点和最低点</strong>作为行框的上下边缘。使用<code>vertical-align</code>可以控制行内盒子在行框中的位置。</p>
<h3 id="单行文本垂直居中"><a href="#单行文本垂直居中" class="headerlink" title="单行文本垂直居中"></a>单行文本垂直居中</h3><p>假如一个<strong>块级元素</strong>中只包含单行的文本，那么可以将文本的行高设置成与块级元素的高度一致。由于行间距的等分特性，那么文字正好可以在块级元素内垂直居中。当然，如果文本超过了一行，这样的方式就行不通了。</p>
<pre><code class="html">&lt;div&gt;我垂直居中啦~&lt;/div&gt;</code></pre>
<pre><code class="css">div {
    height: 300px;
    line-height: 300px;
}</code></pre>
<h3 id="去除图片下方缝隙"><a href="#去除图片下方缝隙" class="headerlink" title="去除图片下方缝隙"></a>去除图片下方缝隙</h3><p>行内元素默认的基线对齐会导致图片下方出现缝隙，这是因为浏览器会在<strong>每个行框的开头</strong>添加一个<strong>没有宽度的、永远透明的空白字符</strong>，规范中称之为<strong>支柱</strong>（strut）。由于支柱的基线下方有一定距离，而图片的基线是下边缘，因此为了基线对齐，图片需要向上移动一小段距离，导致出现了缝隙。</p>
<p><img src="https://ae01.alicdn.com/kf/H32ad8300165d43fc98b0d901b3bede44Q.jpg" alt=""></p>
<p>解决这个问题的方法有很多，比较常见的是将图片的<code>vertical-align</code>改为<code>middle</code>或<code>top</code>，或者将图片设置为块级元素。</p>
</div>
    </div>
</div>

<div class="toc"></div>
    <footer>
    <p>© 2020</p>
    <p>Theme chicken by 小鸡米花, Powered by Hexo</p>
</footer>
    <a class="back-to-top" href="javascript:;"></a>

    <script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
        integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz"
        crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
        integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
        onload="renderMathInElement(document.body, { strict: false, delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}] });"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <script src="/scripts/highlight.pack.js"></script>
    <script src="/live2d/autoload.js" type="text/javascript"></script>
    <script src="/scripts/chicken.js"></script>
    <!-- 
        添加控制台，测试移动端
        <script src="http://cdn.jsdelivr.net/npm/eruda"></script>
        <script>eruda.init();</script>
    -->
</body>

</html>