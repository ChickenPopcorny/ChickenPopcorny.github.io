<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>这是一个神奇的主题</title>
    <!-- <link rel="stylesheet" href="/css/chicken.css"> -->
    <link rel="stylesheet" href="//cdn.yesuanzao.cn/chicken.css">
    <link rel="stylesheet" href="/css/iconfont.css">
    <link rel="stylesheet" href="//cdn.yesuanzao.cn/blog/atom-one-dark.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css">
<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <header>
    <div class="container">
        <div class="site-title"><a href="/">小鸡米花的知识库</a></div>
        <nav>
            <a class="nav-item " href="/">主页</a>
            <a class="nav-item " href="/archives">时光轴</a>
        </nav>
    </div>
</header>
    <div id="write">
    <div class="container">
        <div class="post-info">
            <ul class="tag-list">
                
                    <a class="tag-list-item" href="/tags/JavaScript/">JavaScript</a>
                
            </ul>
        </div>
        <div class="post-content"><h1 id="大前端笔记之13-😍-JavaScript-面向对象"><a href="#大前端笔记之13-😍-JavaScript-面向对象" class="headerlink" title="大前端笔记之13 😍 JavaScript 面向对象"></a>大前端笔记之13 😍 JavaScript 面向对象</h1><p>虽然 JavaScript 对于面向对象的实现与其它语言有所不同，但是它同样是一门面向对象的语言。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>JavaScript 在 ES6 之前没有类的概念，只能通过构造函数作为对象的「模板」。构造函数本质也只是一个普通函数，但是使用<code>new</code>调用后，就可以实例化一个对象。</p>
<pre><code class="js">function Person(name, age) { // 习惯上构造函数首字母大写
    this.name = name
    this.age = age
    this.eat = function() { console.log(&#39;吃呀吃&#39;) }
}

var person = new Person(&#39;Claire&#39;, 19)
person.name // =&gt; Claire</code></pre>
<p>构造函数中使用了<code>this</code>关键字，这里的<code>this</code>指代的是该构造函数创建的<strong>实例对象</strong>。也就是说，构造函数创建的对象是<code>person</code>，因此<code>this.name</code>指的是实例对象<code>person</code>的属性，第二个<code>name</code>则是传递的参数，只用来接收值。</p>
<h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h2><p><code>this</code>在不同场合所指向的对象会有所不同，但是无论如何，它总是会指向一个对象。</p>
<h3 id="构造函数中的-this"><a href="#构造函数中的-this" class="headerlink" title="构造函数中的 this"></a>构造函数中的 this</h3><p>正如上文所说，构造函数中的<code>this</code>指向其创建的实例对象。</p>
<pre><code class="js">function Person(name) { 
    this.name = name 
}

var person = new Person(&#39;Claire&#39;)
person.name // =&gt; Claire</code></pre>
<h3 id="全局作用域中的-this"><a href="#全局作用域中的-this" class="headerlink" title="全局作用域中的 this"></a>全局作用域中的 this</h3><p>全局作用域中的<code>this</code>指代全局对象<code>Window</code>（仅限于浏览器作为宿主环境时）。</p>
<pre><code class="js">console.log(this) // Window</code></pre>
<h3 id="普通函数中的-this"><a href="#普通函数中的-this" class="headerlink" title="普通函数中的 this"></a>普通函数中的 this</h3><p>普通函数中的<code>this</code>指代<strong>当前调用函数的对象</strong>，与函数的定义位置、调用位置都没有关系，只与函数的<strong>调用者</strong>有关。如果函数没有调用者，则<code>this</code>同样指代全局对象<code>Window</code>。</p>
<p>在下面的代码中，由于<code>foo()</code>前没有具体的调用对象，因此函数中的<code>this</code>指代的是<code>Window</code>，从而找到全局作用域中<code>num</code>的值为<code>666</code>。</p>
<pre><code class="js">function foo() {
    var num = 233
    console.log(this.num) 
}

var num = 666
foo() // =&gt; 666</code></pre>
<p>即便是嵌套的函数也是一样：</p>
<pre><code class="js">function outer() {
    var num = 233

    function inner() { console.log(this.num) }
    inner() // 没有调用者，依然是全局对象
}

var a = 666
outer() // =&gt; 666</code></pre>
<p>如果函数是通过对象调用的，那么在该函数中，<code>this</code>指代的就是调用函数的对象。例如：</p>
<pre><code class="js">function foo() { console.log(this.num) }

var obj = { num: 233, fn: foo }
var num = 666

obj.fn() // =&gt; 233</code></pre>
<p>即便函数发生了传递，那么依然也要看<strong>最终调用</strong>时前面是否有对象。因为 ECMAScript 中的函数传递，本质上传递的只是函数的代码。</p>
<pre><code class="js">function foo() { console.log(this.num) }

var obj = { num: 233, fn: foo }
var num = 666

var newFn = obj.fn
newFn() // =&gt; 666，因为最终调用时前面没有对象</code></pre>
<h3 id="定时器函数中的-this"><a href="#定时器函数中的-this" class="headerlink" title="定时器函数中的 this"></a>定时器函数中的 this</h3><p>定时器中的<code>this</code>指代的是全局对象<code>Window</code>。（见<a href="/posts/ybdcxino.html#定时器">BOM</a>一节）</p>
<pre><code class="js">setInterval(function () {
    this // =&gt; window
}, 1000)</code></pre>
<h3 id="事件监听函数中的-this"><a href="#事件监听函数中的-this" class="headerlink" title="事件监听函数中的 this"></a>事件监听函数中的 this</h3><p>事件监听函数中的<code>this</code>指代的是触发事件的对象。（见<a href="/posts/uxfasi54.html">事件</a>一节）</p>
<pre><code class="js">btn.addEventListener(&#39;click&#39;, function () {
    this // =&gt; &lt;button id=&quot;btn&quot;&gt;触发事件&lt;/button&gt;
})</code></pre>
<h3 id="改变-this-指向"><a href="#改变-this-指向" class="headerlink" title="改变 this 指向"></a>改变 this 指向</h3><p>正如上文所说，随着场景不同<code>this</code>的指向也会不同，但是通过一些方式可以修改特定场景下<code>this</code>的指向。</p>
<h4 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h4><p>使用函数调用<code>call()</code>，并传入一个对象作为参数，会导致函数中的<code>this</code>指向该对象参数：</p>
<pre><code class="js">var obj = { age: 18 }
function say() { console.log(this.age) }

say() // =&gt; undefined，this 指向 Window，但是 Window 中没有 age 属性
say.call(obj) // =&gt; 18，this 指向 obj</code></pre>
<p>如果没有传参数或者传入<code>null</code>，那么相当于直接调用函数，不会改变<code>this</code>的指向。</p>
<pre><code class="js">function say() { console.log(this) }

say() // =&gt; Window
say.call() // =&gt; Window</code></pre>
<p>如果传入两个以上的参数，则后面的参数表示函数本身的参数。</p>
<pre><code class="js">function getSum(num1, num2) {
    return num1 + num2
}

getSum.call(null, 10, 20) // =&gt; 30</code></pre>
<h4 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h4><p>它的用法与<code>call()</code>几乎一致，区别在于<code>apply()</code>的函数参数，需要以数组的方式传入。</p>
<pre><code class="js">getSum.apply(obj, [10]) // =&gt; 参数必须是数组</code></pre>
<p>利用这一特性，可以借助<code>Math.max()</code>方法获取数组中的最大值，因为它的参数是若干数值，而使用<code>apply()</code>可以将一个数组作为一系列数值参数传入：</p>
<pre><code class="js">Math.max.apply(null, [10, 20, 30]) // 不需要改变 this 指向，传入 null 即可</code></pre>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h4><p>该方法会改变<code>this</code>的指向，但是不会调用函数，而是返回一个改变了<code>this</code>指向的新函数。</p>
<pre><code class="js">function fn() { console.log(this) }

var obj = {}
var newFn = fn.bind(obj)

newFn() // =&gt; obj</code></pre>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>虽然 JavaScript 提供的构造函数可以作为模板，用来创建多个实例对象。但是，由同一个构造函数创建的多个实例，即使它们的方法是相同的，也会各自开辟空间，这样会造成系统资源的浪费。</p>
<p>在下面的代码中，虽然<code>cat</code>和<code>dog</code>的<code>run()</code>方法内容完全相同，但是指向的对象却不相同。</p>
<pre><code class="js">function Animal() {
    this.run = function () { console.log(&#39;各种跑~&#39;) }
}

var cat = new Animal()
var dog = new Animal()

cat.run == dog.run // =&gt; false</code></pre>
<p>因此，JavaScript 引入了原型（prototype）的概念。原型的<strong>本质是一个对象</strong>，通过构造函数的属性<code>prototype</code>，或者实例对象中的<code>__proto__</code>属性（该属性为浏览器使用，不推荐程序员调用）可以获取。当实例对象在本身找不到要调用的方法时，会通过<code>__proto__</code>属性获取原型对象，再从原型对象中继续寻找。于是，将相同的方法定义到原型对象中，就可以达到<strong>共享资源，节省空间</strong>的目的。</p>
<p><img src="http://cdn.yesuanzao.cn/superbed/2020/02/01/5e34ec812fb38b8c3c329d1a.jpg" alt=""></p>
<p>因此上面的示例可修改为：</p>
<pre><code class="js">function Animal() {}

// 将 run() 方法添加到原型对象中
Animal.prototype.run = function () { console.log(&#39;各种跑~&#39;) }

var cat = new Animal()
var dog = new Animal()

cat.run == dog.run // =&gt; true</code></pre>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>其实原型对象中也有<code>__proto__</code>属性，该属性同样指向另一个原型对象，它们形成了一个链条，称为原型链。</p>
<p>当调用对象的某个属性时，会先从实例对象本身寻找，如果不存在则去它的原型对象中找，如果依然不存在则去它的原型对象的原型对象中找。链条的顶端是<code>Object</code>构造函数的原型对象<code>Object.prototype</code>，该对象不再有原型，其<code>__proto__</code>属性的值为<code>null</code>。</p>
<p><img src="http://cdn.yesuanzao.cn/superbed/2020/02/01/5e34ed192fb38b8c3c32aa92.jpg" alt=""></p>
</div>
    </div>
</div>

<div class="toc"></div>
    <footer>
    <p>© 2020</p>
    <p>Theme chicken by 小鸡米花, Powered by Hexo</p>
</footer>
    <a class="back-to-top" href="javascript:;"></a>

    <script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
    <script defer src="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.js"></script>
    <script defer src="https://cdn.staticfile.org/KaTeX/0.11.1/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, { strict: false, delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}] });"></script>
    <script src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js"></script>
    <script src="https://cdn.staticfile.org/highlight.js/9.18.1/highlight.min.js"></script>

    <script>
        // 为标签追加字体图标
        $('.tag-list-item').prepend('<span class="iconfont icon-biaoqian"></span>')

        // 回到顶部的猫
        $('.back-to-top').click(function () {
            $('html, body').animate({
                scrollTop: 0
            }, 500)
        })

        // 监听 回到顶部的猫 是否显示
        $(document).scroll(function () {
            if ($(document).scrollTop() > 50) {
                $('.back-to-top').addClass('show')
            } else {
                $('.back-to-top').removeClass('show')
            }
        })

        // 在表格外包裹一层，用来生成滚动条
        $('.post-content > table').wrap('<div class="table-container"></div>')

        // Tocbot 实例化，用来快速生成文档目录
        tocbot.init({
            tocSelector: '.toc', // 渲染目录的容器
            contentSelector: '.post-content', // 标题所在的容器
            headingSelector: 'h2, h3', // 要渲染的目录层级,
            headingsOffset: -50, // 微调目录高亮的显示位置（偏移量），防止点击的链接和高亮的链接不一致
        })

        // 初始化代码高亮 highlight.js
        hljs.initHighlightingOnLoad()

        // 自动加载 waifu
        try {
            $("<link>").attr({ href: "//cdn.yesuanzao.cn/blog/live2d/waifu.min.css", rel: "stylesheet", type: "text/css" }).appendTo('head');
            $('body').append('<div class="waifu"><div class="waifu-tips"></div><canvas id="live2d" class="live2d"></canvas><div class="waifu-tool"><span class="fui-home"></span> <span class="fui-chat"></span> <span class="fui-eye"></span> <span class="fui-user"></span> <span class="fui-photo"></span> <span class="fui-info-circle"></span> <span class="fui-cross"></span></div></div>');
            $.ajax({ url: '//cdn.yesuanzao.cn/blog/live2d/waifu-tips.js', dataType: "script", cache: true, async: false });
            $.ajax({ url: '//cdn.yesuanzao.cn/blog/live2d/live2d.min.js', dataType: "script", cache: true, async: false, complete: function() {
                initModel('//cdn.yesuanzao.cn/blog/live2d/waifu-tips.json');
            } });
        } catch (err) { console.log(err) }
    </script>
    <!-- 
        添加控制台，测试移动端
        <script src="http://cdn.jsdelivr.net/npm/eruda"></script>
        <script>eruda.init();</script>
    -->
</body>

</html>