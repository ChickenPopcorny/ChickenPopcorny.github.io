<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>这是一个神奇的主题</title>
    <link rel="stylesheet" href="//cdn.yesuanzao.cn/blog/chicken.css">
    <link rel="stylesheet" href="/css/iconfont.css">
    <link rel="stylesheet" href="//cdn.yesuanzao.cn/blog/atom-one-dark.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css">
<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <header>
    <div class="container">
        <div class="site-title"><a href="/">小鸡米花的知识库</a></div>
        <nav>
            <a class="nav-item " href="/">主页</a>
            <a class="nav-item " href="/archives">时光轴</a>
        </nav>
    </div>
</header>
    <div id="write">
    <div class="container">
        <div class="post-info">
            <ul class="tag-list">
                
                    <a class="tag-list-item" href="/tags/CSS/">CSS</a>
                
            </ul>
        </div>
        <div class="post-content"><h1 id="大前端支线笔记之05-💨-CSS-逐帧动画"><a href="#大前端支线笔记之05-💨-CSS-逐帧动画" class="headerlink" title="大前端支线笔记之05 💨 CSS 逐帧动画"></a>大前端支线笔记之05 💨 CSS 逐帧动画</h1><p>过渡和动画默认的调速函数都是贝塞尔曲线，它会在动画的关键帧之间进行插值运算，使得关键帧之间变化的非常平滑和自然。但是，如果要实现类似于翻书的走马灯效果，那么中间的过渡反而是多余的。</p>
<blockquote>
<p>使用 GIF 图片也是一种选择，但是 GIF 颜色十分单一，并且不具备半透明效果，同时也不方便修改动画速度等参数。</p>
</blockquote>
<p>使用调速函数（<code>transition-timing-function</code>或<code>animation-timing-function</code>）的<code>steps()</code>函数可以使动画逐帧显示，其中的整数值参数表示将<strong>两个关键帧之间的部分</strong>分成几份，而不是整段动画，这一点对于关键帧动画来说尤其需要注意。</p>
<p>首先，使用逐帧动画实现进度条填充的效果，为了方便理解，将其简化成两个阶段，分别为阶段 1（<code>0px ~ 250px</code>）和阶段 2（<code>250px ~ 500px</code>）。</p>
<p><img src="http://q45cwniav.bkt.clouddn.com/superbed/2020/01/24/5e29d11d2fb38b8c3c4e5e11.gif" alt=""></p>
<pre><code class="html">&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;bar&quot;&gt;&lt;/div&gt;
&lt;/div&gt;</code></pre>
<pre><code class="css">.container { width: 500px; }

.bar {
    width: 0%; /* 为了还原现象，需要手动设置进度条的初始值为 0，否则它的默认值为 100% */
    animation: progress 2s steps(2); /* 分为两个阶段，因此设置参数为 2 */
}

@keyframes progress { /* 定义两个关键帧，将这两个帧之间的动画分为两份 */
    0% { width: 0%; }
    100% { width: 100%; }
}</code></pre>
<p>但是，出现的效果可能与想象中有所不同：</p>
<p><img src="http://q45cwniav.bkt.clouddn.com/superbed/2020/01/24/5e29d1f52fb38b8c3c4e7070.gif" alt=""></p>
<p>这是因为，虽然动画阶段有两个，但是分隔后的动画却包含三个关键帧，分别为<code>0%</code>的<code>0px</code>，<code>50%</code>的<code>250px</code>和<code>100%</code>的<code>500px</code>。而<code>steps()</code>只能呈现其中的两个，也就是说<strong>第一帧和最后一帧不能同时出现</strong>。</p>
<p>因此要么只能看到从宽度<code>0px</code>到<code>250px</code>，然后动画结束回到初始状态<code>0px</code>（前提是<code>animation-fill-mode</code>为默认值）；要么只能看到从宽度<code>250px</code>到宽度<code>500px</code>，然后动画结束变为<code>0px</code>。这两种方式分别对应<code>steps()</code>第二个参数的<code>end</code>（默认）和<code>start</code>值（注意顺序正好是相反的）。</p>
<pre><code class="css">.bar { animation: progress 2s steps(2, start); }</code></pre>
<p>如果要显示类似进度条填充的效果，那么需要将进度条的初始宽度设置为<code>500px</code>（或者默认的<code>auto</code>、<code>100%</code>），这样虽然动画只能显示宽度从<code>0</code>到<code>250px</code>，但是由于动画结束时会恢复到初始状态，也就是宽度为<code>500px</code>，看起来就构成了一段完整的动画。</p>
<pre><code class="css">.bar {
    width: 100%; /* 用于动画回到初始状态 */
    animation: progress 2s steps(2);
}</code></pre>
<p>或者，也可以使用<code>animation-fill-mode: forwards</code>设置动画结束时维持在最后一帧（即默认时<code>@keyframes</code>中<code>100%</code>的状态），而不回到初始状态。由于最后一帧定义的为<code>width: 100%</code>，因此也可以实现同样效果。</p>
<pre><code class="css">.bar {
    animation: progress 2s steps(2) forwards; /* 维持在 @keyframes 的最后一帧 */
}</code></pre>
<p>但是，如果动画属性使用了<code>infinite</code>值，那么情况就会变得更麻烦。比如将之前的两种解决方式添加<code>infinite</code>：</p>
<pre><code class="css">.bar { animation: progress 2s steps(2) infinite forwards; }</code></pre>
<p><img src="http://q45cwniav.bkt.clouddn.com/superbed/2020/01/24/5e29fe6b2fb38b8c3c52afe0.gif" alt=""></p>
<p>此时发现效果又没有出现，这是因为，添加了<code>infinite</code>的动画效果没有<strong>完成期</strong>，与<code>forwards</code>根本就没有关系，而且由于它在不断的循环<strong>执行期</strong>，也没法回到动画结束时的初始状态。</p>
<p>为了方便理解，再次将效果简化，只需要<code>0% → 100% → 0%</code>这样一个循环的过程。</p>
<p><img src="http://q45cwniav.bkt.clouddn.com/superbed/2020/01/24/5e2a020e2fb38b8c3c52edd7.gif" alt=""></p>
<p>根据之前的分析，这次只有两个关键帧，因此设置为<code>steps(1)</code>即可。但是这样由于最后一帧不会出现，那么进度条永远为第一帧的白色，不会变成蓝色。</p>
<p>为了解决这个问题，这次需要定义三个关键帧，由于第三个关键帧没法显示，因此将第二个和第三个关键帧设置为同一个状态。为了使时间均匀分布，第二个关键帧的位置需要选在<code>50%</code>。此时<code>100%</code>的关键帧可以省略，因为它默认就与前一帧相同。</p>
<pre><code class="css">@keyframes progress {
    0% { width: 0%; }
    50% { width: 100%; }
    100% { width: 100%; } /* 可以省略 */
}</code></pre>
</div>
    </div>
</div>

<div class="toc"></div>
    <footer>
    <p>© 2020</p>
    <p>Theme chicken by 小鸡米花, Powered by Hexo</p>
</footer>
    <a class="back-to-top" href="javascript:;"></a>

    <script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
    <script defer src="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.js"></script>
    <script defer src="https://cdn.staticfile.org/KaTeX/0.11.1/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, { strict: false, delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}] });"></script>
    <script src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js"></script>
    <script src="https://cdn.staticfile.org/highlight.js/9.18.1/highlight.min.js"></script>
    <script src="http://cdn.yesuanzao.cn/blog/live2d/autoload.js" type="text/javascript"></script>
    <script src="http://cdn.yesuanzao.cn/blog/chicken.js"></script>
    <!-- 
        添加控制台，测试移动端
        <script src="http://cdn.jsdelivr.net/npm/eruda"></script>
        <script>eruda.init();</script>
    -->
</body>

</html>