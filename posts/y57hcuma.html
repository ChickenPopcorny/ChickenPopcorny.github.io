<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>这是一个神奇的主题</title>
    <link rel="stylesheet" href="//cdn.yesuanzao.cn/blog/chicken.css">
    <link rel="stylesheet" href="/css/iconfont.css">
    <link rel="stylesheet" href="//cdn.yesuanzao.cn/blog/atom-one-dark.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css">
<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <header>
    <div class="container">
        <div class="site-title"><a href="/">小鸡米花的知识库</a></div>
        <nav>
            <a class="nav-item " href="/">主页</a>
            <a class="nav-item " href="/archives">时光轴</a>
        </nav>
    </div>
</header>
    <div id="write">
    <div class="container">
        <div class="post-info">
            <ul class="tag-list">
                
                    <a class="tag-list-item" href="/tags/JavaScript/">JavaScript</a>
                
            </ul>
        </div>
        <div class="post-content"><h1 id="大前端笔记之15-❄️-JavaScript-DOM"><a href="#大前端笔记之15-❄️-JavaScript-DOM" class="headerlink" title="大前端笔记之15 ❄️ JavaScript DOM"></a>大前端笔记之15 ❄️ JavaScript DOM</h1><p>浏览器将页面上的元素映射成一个树状的结构，树上的每一个元素称为 DOM 对象（或者叫<strong>节点</strong>）。DOM 对象分为不同的种类，它们都统一继承自<code>Node</code>对象（通过原型链），因此有许多共同的方法和属性：</p>
<ul>
<li><code>Document</code>：整个文档</li>
<li><code>Element</code>：HTML 元素，根据不同的元素又分为<code>HTMLDivElement</code>、<code>HTMLHeadingElement</code>等等</li>
<li><code>Text</code>：元素内的文本</li>
</ul>
<p>由于节点的继承关系比较复杂，可以随时参考<a href="http://w3help.org/zh-cn/causes/SD9024" target="_blank" rel="noopener">这里</a>。</p>
<p>使用<code>window.document</code>属性可以获取文档对象（<code>window</code>可以省略）。而其它节点则可以使用本文下面的各种方式获取。</p>
<h2 id="操作元素"><a href="#操作元素" class="headerlink" title="操作元素"></a>操作元素</h2><p>与元素相关的属性和方法大部分位于<code>document</code>（直接获取）或<code>Element</code>（根据元素上下级关系获取）中。</p>
<h3 id="body-documentElement"><a href="#body-documentElement" class="headerlink" title="body / documentElement"></a>body / documentElement</h3><p>获取<code>&lt;body&gt;</code>/<code>&lt;html&gt;</code>元素对象。</p>
<pre><code class="js">document.body // =&gt; &lt;body&gt;
document.documentElement // =&gt; &lt;html&gt;</code></pre>
<h3 id="getElementById"><a href="#getElementById" class="headerlink" title="getElementById()"></a>getElementById()</h3><p>根据元素的<code>id</code>值获取元素。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>元素的<code>id</code>值，区分大小写</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>元素对象</td>
<td>相应的元素对象，如果有多个元素有相同<code>id</code>，则只返回其中第一个</td>
</tr>
</tbody></table>
<pre><code class="html">&lt;button id=&quot;btn&quot;&gt;这是按钮啦&lt;/button&gt;</code></pre>
<pre><code class="js">document.getElementById(&#39;btn&#39;)</code></pre>
<h3 id="getElementsByName"><a href="#getElementsByName" class="headerlink" title="getElementsByName()"></a>getElementsByName()</h3><p>根据元素的<code>name</code>值获取元素。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>元素的<code>name</code>值</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>NodeList</code>集合</td>
<td>包含符合条件元素的伪数组</td>
</tr>
</tbody></table>
<pre><code class="html">&lt;input type=&#39;text&#39; name=&quot;username&quot;&gt;</code></pre>
<pre><code class="js">document.getElementsByName(&#39;username&#39;)[0]</code></pre>
<h3 id="getElementsByTagName"><a href="#getElementsByTagName" class="headerlink" title="getElementsByTagName()"></a>getElementsByTagName()</h3><p>根据元素的标签名获取元素对象。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>元素的标签名</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>HTMLCollection</code>集合</td>
<td>包含符合条件元素的伪数组</td>
</tr>
</tbody></table>
<pre><code class="js">document.getElementsByTagName(&#39;p&#39;)[0]</code></pre>
<p>元素对象<code>Element</code>也定义了该方法，可以返回元素节点的后代中符合条件的元素。</p>
<pre><code class="js">p.getElementsByTagName(&#39;span&#39;)</code></pre>
<h3 id="getElementsByClassName"><a href="#getElementsByClassName" class="headerlink" title="getElementsByClassName()"></a>getElementsByClassName()</h3><p>根据元素的类名获取元素对象。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>元素的类名，多个类使用空格隔开即可，顺序并不重要</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>HTMLCollection</code>集合</td>
<td>包含符合条件元素的伪数组</td>
</tr>
</tbody></table>
<pre><code class="js">document.getElementsByClassName(&#39;foo bar&#39;) // 返回同时具有 foo 和 bar 两个类的元素</code></pre>
<p>元素对象<code>Element</code>也定义了该方法，可以返回元素节点的后代中符合条件的元素。</p>
<pre><code class="js">p.getElementsByClassName(&#39;foo&#39;) // 获取 p 元素下具有 foo 类的元素</code></pre>
<h3 id="querySelector-querySelectorAll"><a href="#querySelector-querySelectorAll" class="headerlink" title="querySelector() / querySelectorAll()"></a>querySelector() / querySelectorAll()</h3><p>根据 CSS 选择器获取匹配的第一个 / 全部对象。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>CSS 选择器</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>元素对象 / <code>NodeList</code>集合</td>
<td>符合条件的元素 / 包含符合条件元素的伪数组</td>
</tr>
</tbody></table>
<pre><code class="js">document.querySelector(&#39;.btn&#39;) // 获取第一个拥有 btn 类的元素
document.querySelectorAll(&#39;.btn&#39;) // 获取全部拥有 btn 类的元素</code></pre>
<h3 id="firstElementChild-lastElementChild-children"><a href="#firstElementChild-lastElementChild-children" class="headerlink" title="firstElementChild / lastElementChild / children"></a>firstElementChild / lastElementChild / children</h3><p>获取该元素的第一个 / 最后一个 / 所有子元素。</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>元素对象 / <code>HTMLCollection</code>集合</td>
<td>符合条件的元素 / 包含符合条件元素的伪数组</td>
</tr>
</tbody></table>
<pre><code class="html">&lt;ul id=&quot;list&quot;&gt;
    &lt;li id=&quot;first&quot;&gt;冥灯龙&lt;/li&gt;
    &lt;li id=&quot;second&quot;&gt;炎妃龙&lt;/li&gt;
&lt;/ul&gt;</code></pre>
<pre><code class="js">var ul = document.querySelector(&#39;#list&#39;)
ul.children.length // =&gt; 2
ul.firstElementChild // =&gt; &lt;li&gt;冥灯龙&lt;/li&gt;
ul.lastElementChild // =&gt; &lt;li&gt;炎妃龙&lt;/li&gt;</code></pre>
<h3 id="previousElementSibling-nextElementSibling"><a href="#previousElementSibling-nextElementSibling" class="headerlink" title="previousElementSibling / nextElementSibling"></a>previousElementSibling / nextElementSibling</h3><p>获取该元素的前一个 / 后一个兄弟元素。</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>元素对象</td>
<td>符合条件的元素</td>
</tr>
</tbody></table>
<pre><code class="html">&lt;ul id=&quot;list&quot;&gt;
    &lt;li id=&quot;first&quot;&gt;冥灯龙&lt;/li&gt;
    &lt;li id=&quot;second&quot;&gt;炎妃龙&lt;/li&gt;
&lt;/ul&gt;</code></pre>
<pre><code class="js">var first = document.querySelector(&#39;#first&#39;)
first.nextElementSibling // =&gt; &lt;li id=&quot;second&quot;&gt;炎妃龙&lt;/li&gt;</code></pre>
<h3 id="parentElement"><a href="#parentElement" class="headerlink" title="parentElement"></a>parentElement</h3><p>获取该元素的父元素。</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>元素对象</td>
<td>符合条件的元素</td>
</tr>
</tbody></table>
<pre><code class="html">&lt;ul id=&quot;list&quot;&gt;
    &lt;li id=&quot;first&quot;&gt;冥灯龙&lt;/li&gt;
    &lt;li id=&quot;second&quot;&gt;炎妃龙&lt;/li&gt;
&lt;/ul&gt;</code></pre>
<pre><code class="js">var first = document.querySelector(&#39;#first&#39;)
first.parentElement // =&gt; &lt;ul id=&quot;list&quot;&gt;...&lt;/ul&gt;</code></pre>
<h3 id="createElement"><a href="#createElement" class="headerlink" title="createElement()"></a>createElement()</h3><p>创建元素对象，但是创建后的元素需要使用<code>Node</code>中的相关方法插入到文档中才有效果。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>HTML 标签名</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>元素对象</td>
<td>创建的元素对象</td>
</tr>
</tbody></table>
<pre><code class="js">var newDiv = document.createElement(&#39;div&#39;)</code></pre>
<h2 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h2><p>节点相关的属性和方法大部分位于<code>Node</code>中，由于元素对象<code>Element</code>也继承了<code>Node</code>，因此有些方法看起来依然是通过元素对象调用的。</p>
<h3 id="nodeType-nodeName"><a href="#nodeType-nodeName" class="headerlink" title="nodeType / nodeName"></a>nodeType / nodeName</h3><p>获取节点的类型和名称。</p>
<pre><code class="js">document.nodeType // =&gt; 9
document.nodeName // =&gt; #document</code></pre>
<h3 id="firstChild-lastChild-childNodes"><a href="#firstChild-lastChild-childNodes" class="headerlink" title="firstChild / lastChild / childNodes"></a>firstChild / lastChild / childNodes</h3><p>获取该节点的第一个 / 最后一个 / 所有子节点。</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>节点对象 / <code>NodeList</code>集合</td>
<td>符合条件的节点 / 包含符合条件节点的伪数组</td>
</tr>
</tbody></table>
<pre><code class="html">&lt;ul id=&quot;list&quot;&gt;
    &lt;li id=&quot;first&quot;&gt;冥灯龙&lt;/li&gt;
    &lt;li id=&quot;second&quot;&gt;炎妃龙&lt;/li&gt;
&lt;/ul&gt;</code></pre>
<pre><code class="js">var ul = document.querySelector(&#39;#list&#39;)
ul.childNodes.length // =&gt; 5
ul.firstChild.nodeName // =&gt; #text，因为是换行，而不是 &lt;li&gt;</code></pre>
<h3 id="previousSibling-nextSibling"><a href="#previousSibling-nextSibling" class="headerlink" title="previousSibling / nextSibling"></a>previousSibling / nextSibling</h3><p>获取该节点的前一个 / 后一个兄弟节点。</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>节点对象</td>
<td>符合条件的节点</td>
</tr>
</tbody></table>
<pre><code class="html">&lt;ul id=&quot;list&quot;&gt;
    &lt;li id=&quot;first&quot;&gt;冥灯龙&lt;/li&gt;
    &lt;li id=&quot;second&quot;&gt;炎妃龙&lt;/li&gt;
&lt;/ul&gt;</code></pre>
<pre><code class="js">var first = document.querySelector(&#39;#first&#39;)
first.nextSibling.nodeName // =&gt; #text，是一个换行，而不是 &lt;li&gt;</code></pre>
<h3 id="parentNode"><a href="#parentNode" class="headerlink" title="parentNode"></a>parentNode</h3><p>获取该节点的父节点。</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>节点对象</td>
<td>符合条件的节点</td>
</tr>
</tbody></table>
<pre><code class="html">&lt;ul id=&quot;list&quot;&gt;
    &lt;li id=&quot;first&quot;&gt;冥灯龙&lt;/li&gt;
    &lt;li id=&quot;second&quot;&gt;炎妃龙&lt;/li&gt;
&lt;/ul&gt;</code></pre>
<pre><code class="js">var first = document.querySelector(&#39;#first&#39;)
first.parentNode // =&gt; &lt;ul id=&quot;list&quot;&gt;...&lt;/ul&gt;</code></pre>
<h3 id="cloneNode"><a href="#cloneNode" class="headerlink" title="cloneNode()"></a>cloneNode()</h3><p>复制节点。与<code>createElement()</code>一样，复制后的节点需要使用<code>Node</code>中的相关方法插入到文档中才有效果。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>布尔值</td>
<td>可选。默认值<code>false</code>为浅拷贝，表示仅复制该节点本身，不包括后代节点；<code>true</code>为深拷贝，表示连同后代节点一同复制</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>节点对象</td>
<td>复制的节点</td>
</tr>
</tbody></table>
<pre><code class="html">&lt;ul id=&quot;list&quot;&gt;
    &lt;li id=&quot;first&quot;&gt;冥灯龙&lt;/li&gt;
&lt;/ul&gt;</code></pre>
<pre><code class="js">var list = document.querySelector(&#39;#list&#39;)
var newList = list.cloneNode(true) // 如果为 false，则不会拷贝 &lt;li id=&quot;first&quot;&gt;冥灯龙&lt;/li&gt; 这个子节点</code></pre>
<h3 id="appendChild"><a href="#appendChild" class="headerlink" title="appendChild()"></a>appendChild()</h3><p>将一个节点插入到父节点的最后，作为其最后一个子节点。如果要插入的节点是页面上已经存在的，那么该方法会<strong>移动</strong>该节点，而不是复制。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>节点对象</td>
<td>要插入的节点</td>
</tr>
</tbody></table>
<pre><code class="html">&lt;ul id=&quot;list&quot;&gt;
    &lt;li id=&quot;first&quot;&gt;冥灯龙&lt;/li&gt;
&lt;/ul&gt;</code></pre>
<pre><code class="js">var list = document.querySelector(&#39;#list&#39;)
var first = document.querySelector(&#39;#first&#39;)

var newItem = first.cloneNode(true) // 必须设置为 true，否则无法克隆 冥灯龙 这个文本节点

list.appendChild(newItem)

// &lt;ul id=&quot;list&quot;&gt;
//     &lt;li id=&quot;first&quot;&gt;冥灯龙&lt;/li&gt;
//     &lt;li id=&quot;first&quot;&gt;冥灯龙&lt;/li&gt;
// &lt;/ul&gt;</code></pre>
<h3 id="insertBefore"><a href="#insertBefore" class="headerlink" title="insertBefore()"></a>insertBefore()</h3><p>将一个节点插入到父节点的内部，作为子节点。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>节点对象</td>
<td>要插入的节点</td>
</tr>
<tr>
<td>节点对象</td>
<td>父节点的一个内部节点，新节点将插入到该内部节点之前</td>
</tr>
</tbody></table>
<pre><code class="html">&lt;ul id=&quot;list&quot;&gt;
    &lt;li id=&quot;first&quot;&gt;冥灯龙&lt;/li&gt;
    &lt;li id=&quot;second&quot;&gt;炎妃龙&lt;/li&gt;
&lt;/ul&gt;</code></pre>
<pre><code class="js">var list = document.querySelector(&#39;#list&#39;)
var newItem = document.createElement(&#39;li&#39;) // 创建新元素
var second = document.querySelector(&#39;#second&#39;)

list.insertBefore(newItem, second) // 将新元素插入到 second 之前

// &lt;ul id=&quot;list&quot;&gt;
//     &lt;li id=&quot;first&quot;&gt;冥灯龙&lt;/li&gt;
//     &lt;li&gt;&lt;/li&gt;
//     &lt;li id=&quot;second&quot;&gt;炎妃龙&lt;/li&gt;
// &lt;/ul&gt;</code></pre>
<h3 id="removeChild"><a href="#removeChild" class="headerlink" title="removeChild()"></a>removeChild()</h3><p>移除当前节点中的一个子节点。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>节点对象</td>
<td>要移除的节点</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>节点对象</td>
<td>已移除的节点</td>
</tr>
</tbody></table>
<pre><code class="html">&lt;ul id=&quot;list&quot;&gt;
    &lt;li id=&quot;first&quot;&gt;冥灯龙&lt;/li&gt;
    &lt;li id=&quot;second&quot;&gt;炎妃龙&lt;/li&gt;
&lt;/ul&gt;</code></pre>
<pre><code class="js">var list = document.querySelector(&#39;#list&#39;)
var second = document.querySelector(&#39;#second&#39;)

list.removeChild(second)

// &lt;ul id=&quot;list&quot;&gt;
//     &lt;li id=&quot;first&quot;&gt;冥灯龙&lt;/li&gt;
// &lt;/ul&gt;</code></pre>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>为了保存多个元素 / 节点对象，DOM 提供了两个伪数组对象作为集合，它们与<code>Node</code>平级，是两个独立于<code>Node</code>的特殊对象。</p>
<h3 id="HTMLCollection"><a href="#HTMLCollection" class="headerlink" title="HTMLCollection"></a>HTMLCollection</h3><p>保存多个元素对象。</p>
<pre><code class="js">p.children.length // HTMLCollection 的长度</code></pre>
<h3 id="NodeList"><a href="#NodeList" class="headerlink" title="NodeList"></a>NodeList</h3><p>保存多个节点对象。</p>
<pre><code class="js">p.childNodes.length // NodeList 的长度</code></pre>
<h2 id="操作文本"><a href="#操作文本" class="headerlink" title="操作文本"></a>操作文本</h2><p>文本对象<code>Text</code>本身也是节点之一，但是由于直接使用它的可能性不大，因此通常都是用元素对象<code>Element</code>的相关属性获取文本内容即可。</p>
<h3 id="textContent-innerText"><a href="#textContent-innerText" class="headerlink" title="textContent / innerText"></a>textContent / innerText</h3><p>获取元素内部的所有文本内容，也可以用来修改元素内容。它们会忽略内容中的 HTML 标签，返回只包含文字部分的内容，将 HTML 输出到页面也只会显示代码，不会被解析。</p>
<pre><code class="html">&lt;span id=&quot;msg&quot;&gt;这里是&lt;strong&gt;文本内容&lt;/strong&gt;啦&lt;/span&gt;</code></pre>
<pre><code class="js">var msg = document.querySelector(&#39;msg&#39;)

msg.textContent // =&gt; 这里是文本内容啦
msg.innerText // =&gt; 这里是文本内容啦</code></pre>
<h3 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h3><p>获取元素内部的所有 HTML 代码，也可以用来修改元素内容。它不会忽略内容中的 HTML 标签，将 HTML 输出到页面会将其解析。</p>
<pre><code class="html">&lt;span id=&quot;msg&quot;&gt;这里是&lt;strong&gt;文本内容&lt;/strong&gt;啦&lt;/span&gt;</code></pre>
<pre><code class="js">var msg = document.querySelector(&#39;msg&#39;)

msg.innerHTML // =&gt; 这里是&lt;strong&gt;文本内容&lt;/strong&gt;啦</code></pre>
<h2 id="操作属性"><a href="#操作属性" class="headerlink" title="操作属性"></a>操作属性</h2><p>DOM 会自动为每个元素添加其标签上的属性（自定义属性除外），通过它们可以直接获取元素的属性值。</p>
<pre><code class="html">&lt;a id=&quot;test&quot;&gt;&lt;/a&gt;</code></pre>
<pre><code class="js">a.id // =&gt; test
a.href = &#39;http://www.example.com&#39; // 修改属性值</code></pre>
<p>对于布尔型的属性，也应该使用布尔型的值：</p>
<pre><code class="js">input.disable = true
radio.checked = true</code></pre>
<h3 id="className"><a href="#className" class="headerlink" title="className"></a>className</h3><p>获取元素的完整类名称。</p>
<pre><code class="html">&lt;div class=&quot;one two three&quot;&gt;&lt;/div&gt;</code></pre>
<pre><code class="js">div.className // =&gt; &#39;one two three&#39; </code></pre>
<h3 id="classList"><a href="#classList" class="headerlink" title="classList"></a>classList</h3><p>不过完整的类属性字符串很难操作，因此 DOM 提供了<code>classList</code>可以获取一个类属性对象，它包含下列属性和方法：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>length</code></td>
<td>获取类的数量，只读</td>
</tr>
<tr>
<td><code>add()</code></td>
<td>增加类</td>
</tr>
<tr>
<td><code>remove()</code></td>
<td>移除类</td>
</tr>
<tr>
<td><code>contains()</code></td>
<td>检查当前对象是否包含某个类</td>
</tr>
<tr>
<td><code>toggle()</code></td>
<td>如果某个类存在，则移除该类，否则添加该类</td>
</tr>
<tr>
<td><code>item()</code></td>
<td>返回指定索引位置的类，注意<strong>没有方括号</strong>形式</td>
</tr>
</tbody></table>
<pre><code class="js">div.classList // =&gt; { 0: &quot;one&quot;, 1: &quot;two&quot;, 2: &quot;three&quot;, length: 3 }
div.classList.add(&#39;btn&#39;)
div.classList.add(&#39;btn&#39;, &#39;danger&#39;)
div.classList.remove(&#39;btn&#39;)
div.classList.toggle(&#39;btn&#39;)
div.classList.contains(&#39;btn&#39;)
div.classList.item(0) // 没有 div.classList[0] 这样的格式</code></pre>
<h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><p>使用 HTML 标准提供的<code>data-</code>前缀形式可以添加自定义属性：</p>
<pre><code class="js">&lt;div id=&quot;person&quot; data-score=&quot;30&quot;&gt;&lt;/div&gt;</code></pre>
<p>然后，通过元素对象的<code>dataset</code>属性，可以<strong>读写</strong>标签的所有<code>data-</code>属性：</p>
<pre><code class="js">person.dataset.score // =&gt; 30</code></pre>
<p>注意，<code>data-</code>后面的属性名不要使用大写字母，因为 HTML 不区分大小写。比如<code>data-helloWorld</code>应该写成<code>data-hello-world</code>。当它转成<code>dataset</code>的属性名时，会自动将短横线后面的字母转为大写，并移除短横线，反之也是一样。</p>
<pre><code class="html">&lt;div id=&quot;person&quot; data-max-score=&quot;30&quot;&gt;&lt;/div&gt;</code></pre>
<pre><code class="js">person.dataset.maxScore // =&gt; 30</code></pre>
<h2 id="操作样式"><a href="#操作样式" class="headerlink" title="操作样式"></a>操作样式</h2><p>元素样式相关的属性和方法均位于<code>Element</code>元素对象中。</p>
<h3 id="style"><a href="#style" class="headerlink" title="style"></a>style</h3><p>设置元素的<strong>行内样式</strong>，但不能操作定义在<strong>样式表中的规则</strong>。对于包含连字符的属性名称，需要变成驼峰式写法。</p>
<pre><code class="js">div.style.width = &#39;100px&#39;;
div.style.backgroundColor = &#39;orange&#39;;</code></pre>
<h3 id="getComputedStyle"><a href="#getComputedStyle" class="headerlink" title="getComputedStyle()"></a>getComputedStyle()</h3><p>获取元素计算后的最终样式。但是该对象获取的属性值是<strong>只读</strong>的，因此它只能获取样式，要设置样式只能使用<code>style</code>属性。</p>
<pre><code class="js">getComputedStyle(div).width</code></pre>
<h3 id="元素大小"><a href="#元素大小" class="headerlink" title="元素大小"></a>元素大小</h3><p>使用下列属性可以获取元素大小相关的信息，它们均<strong>不包含单位</strong>。</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>scrollWidth</code></td>
<td><strong>只读</strong>，获取元素的内容宽度，包括溢出容器的部分。如果内容没有占满容器，那么与<code>clientWidth</code>一致</td>
</tr>
<tr>
<td><code>scrollHeight</code></td>
<td><strong>只读</strong>，获取元素的内容高度，包括溢出容器的部分。如果内容没有占满容器，那么与<code>clientHeight</code>一致</td>
</tr>
<tr>
<td><code>offsetWidth</code></td>
<td><strong>只读</strong>，获取元素以<code>border</code>为界的宽度</td>
</tr>
<tr>
<td><code>offsetHeight</code></td>
<td><strong>只读</strong>，获取元素以<code>border</code>为界的高度</td>
</tr>
<tr>
<td><code>clientWidth</code></td>
<td>只适用于<strong>块级元素</strong>，获取元素以<code>padding</code>为界的宽度</td>
</tr>
<tr>
<td><code>clientHeight</code></td>
<td>只适用于<strong>块级元素</strong>，获取元素以<code>padding</code>为界的高度</td>
</tr>
<tr>
<td><code>clientLeft</code></td>
<td>只适用于<strong>块级元素</strong>，获取元素<code>border-left</code>的大小</td>
</tr>
<tr>
<td><code>clientTop</code></td>
<td>只适用于<strong>块级元素</strong>，获取元素<code>border-top</code>的大小</td>
</tr>
</tbody></table>
<pre><code class="js">div.offsetWidth // =&gt; 300</code></pre>
<h3 id="滚动距离"><a href="#滚动距离" class="headerlink" title="滚动距离"></a>滚动距离</h3><p>使用下列属性可以获取元素滚动距离相关的信息，它们均<strong>不包含单位</strong>。</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>scrollLeft</code></td>
<td><strong>可读写</strong>，获取元素内容水平方向滚动出去的距离，如果元素没有滚动条，那么该值为<code>0</code></td>
</tr>
<tr>
<td><code>scrollTop</code></td>
<td><strong>可读写</strong>，获取元素内容垂直方向滚动出去的距离，如果元素没有滚动条，那么该值为<code>0</code></td>
</tr>
<tr>
<td><code>pageXOffset</code></td>
<td><strong>只读</strong>，获取页面的水平滚动距离</td>
</tr>
<tr>
<td><code>pageYOffset</code></td>
<td><strong>只读</strong>，获取页面的垂直滚动距离</td>
</tr>
</tbody></table>
<p><img src="https://ae01.alicdn.com/kf/Hee8a50876f8941ed89036973f32d9f5fH.jpg" alt=""></p>
<blockquote>
<p>如果使用<code>scrollTop</code>获取整个页面滚动的话，在 Chrome 和 IE 中，必须使用<code>document.documentElement.scrollTop</code>才能正确获取，其它方式该值均为<code>0</code>。</p>
</blockquote>
<pre><code class="js">document.addEventListener(&#39;scroll&#39;, function() {
    window.pageYoffset
    document.documentElement.scrollTop
})</code></pre>
<h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p>使用下列属性可以获取元素位置相关的信息，它们均<strong>不包含单位</strong>。</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>offsetParent</code></td>
<td><strong>只读</strong>，获取最靠近当前元素的，且 CSS 的<code>position</code>属性不等于<code>static</code>的父元素，直到<code>&lt;body&gt;</code>元素</td>
</tr>
<tr>
<td><code>offsetLeft</code></td>
<td><strong>只读</strong>，获取元素相对于<code>offsetParent</code>元素左侧的偏移距离</td>
</tr>
<tr>
<td><code>offsetTop</code></td>
<td><strong>只读</strong>，获取元素相对于<code>offsetParent</code>元素上方的偏移距离</td>
</tr>
</tbody></table>
<blockquote>
<p>注意，如果元素中包含未设置宽高的图片，那么由于代码执行时图片可能还没加载，从而导致无法正确获取元素距离顶部的高度</p>
</blockquote>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>除了上述通用属性和方法以外，有些特定元素还定义了独有的属性和方法。</p>
<h3 id="submit"><a href="#submit" class="headerlink" title="submit()"></a>submit()</h3><p>使用<code>HTMLFormElement</code>的<code>submit()</code>方法可以直接提交表单。</p>
<pre><code class="js">form.submit()</code></pre>
<h3 id="focus"><a href="#focus" class="headerlink" title="focus()"></a>focus()</h3><p>使用<code>HTMLElement</code>的<code>focus()</code>方法可以使元素获得焦点（通常用在表单控件元素上）。</p>
<pre><code class="js">input.focus()</code></pre>
</div>
    </div>
</div>

<div class="toc"></div>
    <footer>
    <p>© 2020</p>
    <p>Theme chicken by 小鸡米花, Powered by Hexo</p>
</footer>
    <a class="back-to-top" href="javascript:;"></a>

    <script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
    <script defer src="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.js"></script>
    <script defer src="https://cdn.staticfile.org/KaTeX/0.11.1/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, { strict: false, delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}] });"></script>
    <script src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js"></script>
    <script src="https://cdn.staticfile.org/highlight.js/9.18.1/highlight.min.js"></script>
    <script src="/css/autoload.js"></script>

    <script>
        // 为标签追加字体图标
        $('.tag-list-item').prepend('<span class="iconfont icon-biaoqian"></span>')

        // 回到顶部的猫
        $('.back-to-top').click(function () {
            $('html, body').animate({
                scrollTop: 0
            }, 500)
        })

        // 监听 回到顶部的猫 是否显示
        $(document).scroll(function () {
            if ($(document).scrollTop() > 50) {
                $('.back-to-top').addClass('show')
            } else {
                $('.back-to-top').removeClass('show')
            }
        })

        // 在表格外包裹一层，用来生成滚动条
        $('.post-content > table').wrap('<div class="table-container"></div>')

        // Tocbot 实例化，用来快速生成文档目录
        tocbot.init({
            tocSelector: '.toc', // 渲染目录的容器
            contentSelector: '.post-content', // 标题所在的容器
            headingSelector: 'h2, h3', // 要渲染的目录层级,
            headingsOffset: -50, // 微调目录高亮的显示位置（偏移量），防止点击的链接和高亮的链接不一致
        })

        // 初始化代码高亮 highlight.js
        hljs.initHighlightingOnLoad()

        // 自动加载 waifu
        try {
            $("<link>").attr({ href: "//cdn.yesuanzao.cn/blog/live2d/waifu.min.css", rel: "stylesheet", type: "text/css" }).appendTo('head');
            $('body').append('<div class="waifu"><div class="waifu-tips"></div><canvas id="live2d" class="live2d"></canvas><div class="waifu-tool"><span class="fui-home"></span> <span class="fui-chat"></span> <span class="fui-eye"></span> <span class="fui-user"></span> <span class="fui-photo"></span> <span class="fui-info-circle"></span> <span class="fui-cross"></span></div></div>');
            $.ajax({ url: '//cdn.yesuanzao.cn/blog/live2d/waifu-tips.js', dataType: "script", cache: false, async: false });
            $.ajax({ url: '//cdn.yesuanzao.cn/blog/live2d/live2d.min.js', dataType: "script", cache: false, async: false, complete: function() {
                initModel('//cdn.yesuanzao.cn/blog/live2d/waifu-tips.json');
            } });
        } catch (err) { console.log(err) }
    </script>
    <!-- 
        添加控制台，测试移动端
        <script src="http://cdn.jsdelivr.net/npm/eruda"></script>
        <script>eruda.init();</script>
    -->
</body>

</html>