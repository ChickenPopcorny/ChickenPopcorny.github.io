<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>这是一个神奇的主题</title>
    <link rel="stylesheet" href="/css/chicken.css">
    <link rel="stylesheet" href="/css/iconfont.css">
    <link rel="stylesheet" href="/css/atom-one-dark.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
        integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css">
<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <header>
    <div class="container">
        <div class="site-title"><a href="/">小鸡米花的知识库</a></div>
        <nav>
            <a class="nav-item " href="/">主页</a>
            <a class="nav-item " href="/archives">时光轴</a>
        </nav>
    </div>
</header>
    <div id="write">
    <div class="container">
        <div class="post-info">
            <ul class="tag-list">
                
                    <a class="tag-list-item" href="/tags/JavaScript/">JavaScript</a>
                
            </ul>
        </div>
        <div class="post-content"><h1 id="大前端笔记之16-⏰-JavaScript-BOM"><a href="#大前端笔记之16-⏰-JavaScript-BOM" class="headerlink" title="大前端笔记之16 ⏰ JavaScript BOM"></a>大前端笔记之16 ⏰ JavaScript BOM</h1><p>BOM（Browser Object Model，浏览器对象模型）也是浏览器提供的一个 API。通过 BOM 可以控制浏览器视口以外的部分，比如浏览器的窗口和框架等等。</p>
<p>下面的大部分属性和方法均属于<code>window</code>对象，它指代当前的浏览器窗口，是当前页面中的顶层对象。调用它的属性和方法均可以省略<code>window</code>，比如可以写<code>alert()</code>而不是<code>window.alert()</code>。</p>
<h2 id="弹框"><a href="#弹框" class="headerlink" title="弹框"></a>弹框</h2><p>下列原生的浏览器弹框样式无法修改，并且在对话框弹出期间，浏览器窗口处于冻结状态，用户无法进行其它操作，因此不推荐使用。</p>
<h3 id="alert"><a href="#alert" class="headerlink" title="alert()"></a>alert()</h3><p>弹出普通提示框。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>对话框内容</td>
</tr>
</tbody></table>
<pre><code class="js">alert(&#39;烦人的对话框&#39;)</code></pre>
<h3 id="prompt"><a href="#prompt" class="headerlink" title="prompt()"></a>prompt()</h3><p>弹出输入对话框，用来获取用户输入。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>对话框内容</td>
</tr>
<tr>
<td>字符串</td>
<td>可选，输入框的默认值</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符串 / <code>null</code></td>
<td>用户输入的内容，如果用户点击取消则返回<code>null</code></td>
</tr>
</tbody></table>
<pre><code class="js">var result = prompt(&#39;请输出您的年龄&#39;, 38)</code></pre>
<h3 id="confirm"><a href="#confirm" class="headerlink" title="confirm()"></a>confirm()</h3><p>弹出判断对话框，用来获取用户输入。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>对话框内容</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>布尔值</td>
<td>用户点击确定返回<code>true</code>，否则返回<code>false</code></td>
</tr>
</tbody></table>
<pre><code class="js">var result = confirm(&#39;您确定要离开吗？&#39;)</code></pre>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>定时器可以用来设置某段代码在特定时间之后 / 每隔特定时间执行。</p>
<h3 id="setTimeout-setInterval"><a href="#setTimeout-setInterval" class="headerlink" title="setTimeout() / setInterval()"></a>setTimeout() / setInterval()</h3><p>创建定时器。区别在于前者是延迟一段时间执行，后者是每隔一段时间执行。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>函数</td>
<td>要定时执行的函数</td>
</tr>
<tr>
<td>整数值</td>
<td>延迟时间 / 间隔时间，单位为毫秒</td>
</tr>
<tr>
<td>若干对象</td>
<td>执行函数的参数</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>整数值</td>
<td>定时器的编号</td>
</tr>
</tbody></table>
<pre><code class="js">var id1 = setTimeout(function(){
    console.log(&#39;延迟一秒后输出！&#39;)
}, 1000)

var id2 = setInterval(function(){
    console.log(&#39;每隔一秒输出！&#39;)
}, 1000)

setTimeout(function(msg) { // 1 秒后输出 hello
    console.log(msg)
}, 1000, &#39;hello&#39;) </code></pre>
<h3 id="clearTimeout-clearInterval"><a href="#clearTimeout-clearInterval" class="headerlink" title="clearTimeout() / clearInterval()"></a>clearTimeout() / clearInterval()</h3><p>清除定时器。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>整数值</td>
<td>定时器的编号</td>
</tr>
</tbody></table>
<pre><code class="js">var id = setTimeout(function(){
    console.log(&#39;延迟一秒后输出！&#39;)
}, 1000)

clearTimeout(id)</code></pre>
<h2 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h2><p>使用<code>window.location</code>属性可以获取<code>Location</code>对象，它包含了与 URL 相关的属性和方法。</p>
<h3 id="相关属性"><a href="#相关属性" class="headerlink" title="相关属性"></a>相关属性</h3><p>下列属性都是<strong>可读写</strong>的，因此修改<code>href</code>属性的值会导致页面发生跳转。</p>
<pre><code class="js">// 当前 URL 为：http://www.example.com:4097/path/a.html?x=111#part1

location.href      // 完整 URL：&quot;http://www.example.com:4097/path/a.html?x=111#part1&quot;
location.protocol  // 协议：&quot;http:&quot;
location.host      // 主机：&quot;www.example.com:4097&quot;
location.hostname  // 主机名称：&quot;www.example.com&quot;
location.port      // 端口号：&quot;4097&quot;
location.pathname  // 路径：&quot;/path/a.html&quot;
location.search    // 提交参数：&quot;?x=111&quot;
location.hash      // 哈希值：&quot;#part1&quot;</code></pre>
<h3 id="replace-assign"><a href="#replace-assign" class="headerlink" title="replace() / assign()"></a>replace() / assign()</h3><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>要跳转的页面地址</td>
</tr>
</tbody></table>
<p>使当前页面跳转到新的地址。它们的区别在于，<code>replace()</code>方法会删除历史记录中之前的地址，也就是说当页面跳转后，浏览器的后退按钮就无法使用了。而通过<code>assign()</code>和<code>href</code>跳转的页面依然可以后退。</p>
<pre><code class="js">location.replace(&#39;http://www.example.com&#39;)

location.assign(&#39;http://www.example.com&#39;)
location.href = &#39;http://www.example.com&#39;</code></pre>
<h3 id="reload"><a href="#reload" class="headerlink" title="reload()"></a>reload()</h3><p>刷新当前页面，相当于浏览器的刷新按钮。</p>
<pre><code class="js">location.reload()</code></pre>
<h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><p>使用<code>window.history</code>属性可以获取<code>History</code>对象，它包含了与历史记录相关的属性和方法。注意，调用这些方法修改页面地址不会导致向服务器发送请求，因此它们也是<a href="/posts/ovrgsm0u.html#前端路由">前端路由</a>的一种实现方式。</p>
<h3 id="back-forward"><a href="#back-forward" class="headerlink" title="back() / forward()"></a>back() / forward()</h3><p>跳转到上一个 / 下一个浏览的页面，相当于浏览器的后退 / 前进按钮。如果不存在上一个或下一个页面，那么该方法无效。</p>
<pre><code class="js">history.back()
history.forward()</code></pre>
<h3 id="go"><a href="#go" class="headerlink" title="go()"></a>go()</h3><p>以当前网址为基准，跳转到前 n 个 / 后 n 个页面。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>整数值</td>
<td>负值表示后退，正值表示前进，<code>0</code>相当于刷新页面</td>
</tr>
</tbody></table>
<pre><code class="js">history.go(-1) // 相当于 back()
history.go(1) // 相当于 forward()
history.go(0) // 相当于 刷新页面</code></pre>
<h3 id="pushState"><a href="#pushState" class="headerlink" title="pushState()"></a>pushState()</h3><p>历史记录本质是一个栈结构，当前的 URL 就是栈顶的值。使用<code>pushState()</code>可以向栈中压入一条记录，使当前的 URL 发生改变。</p>
<pre><code class="js">// 使 URL 由 http://localhost:8080/ 变成 http://localhost:8080/home，前两个参数固定为空即可，基本没有作用
history.pushState({}, &#39;&#39;, &#39;home&#39;)</code></pre>
<h3 id="replaceState"><a href="#replaceState" class="headerlink" title="replaceState()"></a>replaceState()</h3><p>与<code>pushState()</code>类似，但是它是直接替换栈顶的值，因此虽然当前的 URL 也会发生改变，但是前进后退按钮是不可用的，因为栈中并没有添加新的历史记录。</p>
<pre><code class="js">// 使 URL 由 http://localhost:8080/home 变成 http://localhost:8080/about
history.replaceState({}, &#39;&#39;, &#39;about&#39;)</code></pre>
<h2 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h2><p>使用<code>window.navigator</code>属性可以获取<code>Navigator</code>对象，它包含了与用户环境相关的属性和方法。</p>
<pre><code class="js">navigator.userAgent // 浏览器的厂商和版本
navigator.platform // 用户的操作系统信息</code></pre>
<p>下面的代码可以简单判断用户的设备：</p>
<pre><code class="js">if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) {
    /* 手机端 */
} else {
    /* PC 端 */
}</code></pre>
<h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>使用<code>document</code>对象的<code>cookie</code>属性获取<code>Cookie</code>对象，包含了本域的所有 Cookie。它的值为字符串，多个 Cookie 以分号隔开，必须手动拆分才能获取每一个 Cookie 的值。</p>
<pre><code class="js">var cookies = document.cookie // =&gt; &#39;foo=bar;baz=bar&#39;

for (var i = 0; i &lt; cookies.length; i++) {
    cookies[i]
}
// =&gt; foo=bar
// =&gt; baz=bar</code></pre>
<blockquote>
<p>由于原生操作的复杂性，可以使用第三方插件来操作 Cookie，比如 <a href="https://github.com/js-cookie/js-cookie" target="_blank" rel="noopener">JavaScript Cookie</a> 。</p>
</blockquote>
<h3 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h3><p>Web Storage 是 HTML5 新增的本地存储 API，同样使用键值对来保存数据。相比于传统的 Cookie，它的存储空间更大，操作也更加方便。使用<code>window</code>对象的<code>sessionStorage</code>或<code>localStorage</code>属性可以获取相应的对象，它们的方法和属性都是相同的，区别在于前者存储的数据在浏览器关闭后就会清空，使用相对较少；后者存储的数据则会一直存在。</p>
<p>它们的主要方法如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>setItem()</code></td>
<td>存储一条数据，它的两个参数为<strong>字符串</strong>（不然会类型转换）。对于一些复杂的数据格式，应该转换为 JSON 后再保存</td>
</tr>
<tr>
<td><code>getItem()</code></td>
<td>根据键获取对应数据</td>
</tr>
<tr>
<td><code>removeItem()</code></td>
<td>根据键删除对应数据</td>
</tr>
<tr>
<td><code>clear()</code></td>
<td>清除当前域下的所有数据</td>
</tr>
</tbody></table>
<pre><code class="js">sessionStorage.setItem(&#39;bgcolor&#39;, &#39;red&#39;)
localStorage.setItem(&#39;name&#39;, &#39;Saber&#39;)
localStorage.getItem(&#39;name&#39;) // =&gt; Saber
localStorage.removeItem(&#39;name&#39;)
localStorage.clear()</code></pre>
<h2 id="Selection"><a href="#Selection" class="headerlink" title="Selection"></a>Selection</h2><p>使用<code>window</code>对象的<code>getSelection()</code>方法可以获取<code>Selection</code>对象，它包含了与用户选中文本相关的属性和方法。</p>
<h3 id="removeAllRanges"><a href="#removeAllRanges" class="headerlink" title="removeAllRanges()"></a>removeAllRanges()</h3><p>禁止用户选择页面文本。</p>
<pre><code class="js">getSelection().removeAllRanges()</code></pre>
</div>
    </div>
</div>

<div class="toc"></div>
    <footer>
    <p>© 2020</p>
    <p>Theme chicken by 小鸡米花, Powered by Hexo</p>
</footer>
    <a class="back-to-top" href="javascript:;"></a>

    <script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
        integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz"
        crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
        integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
        onload="renderMathInElement(document.body, { strict: false, delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}] });"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <script src="/scripts/highlight.pack.js"></script>
    <script src="/live2d/autoload.js" type="text/javascript"></script>
    <script src="/scripts/chicken.js"></script>
    <!-- 
        添加控制台，测试移动端
        <script src="http://cdn.jsdelivr.net/npm/eruda"></script>
        <script>eruda.init();</script>
    -->
</body>

</html>