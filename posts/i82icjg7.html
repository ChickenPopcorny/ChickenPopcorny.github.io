<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>这是一个神奇的主题</title>
    <link rel="stylesheet" href="//cdn.yesuanzao.cn/blog/chicken.css">
    <link rel="stylesheet" href="/css/iconfont.css">
    <link rel="stylesheet" href="//cdn.yesuanzao.cn/blog/atom-one-dark.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css">
<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <header>
    <div class="container">
        <div class="site-title"><a href="/">小鸡米花的知识库</a></div>
        <nav>
            <a class="nav-item " href="/">主页</a>
            <a class="nav-item " href="/archives">时光轴</a>
        </nav>
    </div>
</header>
    <div id="write">
    <div class="container">
        <div class="post-info">
            <ul class="tag-list">
                
                    <a class="tag-list-item" href="/tags/JavaScript/">JavaScript</a>
                
            </ul>
        </div>
        <div class="post-content"><h1 id="大前端笔记之14-🔌-JavaScript-标准库"><a href="#大前端笔记之14-🔌-JavaScript-标准库" class="headerlink" title="大前端笔记之14 🔌 JavaScript 标准库"></a>大前端笔记之14 🔌 JavaScript 标准库</h1><p>本节均是一些 JavaScript 提供的常用 API，需要时查询即可。</p>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><h3 id="indexOf-lastIndexOf"><a href="#indexOf-lastIndexOf" class="headerlink" title="indexOf() / lastIndexOf()"></a>indexOf() / lastIndexOf()</h3><p>获取元素在数组中首次出现的索引位置。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>对象</td>
<td>要查找的元素</td>
</tr>
<tr>
<td>数值</td>
<td>可选，表示从该索引位置（包括）向后查找</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数值</td>
<td>元素在数组中首次出现的索引位置，如果不存在返回<code>-1</code></td>
</tr>
</tbody></table>
<pre><code class="js">var array = [10, 20, 30, 20]
array.indexOf(20) // =&gt; 1
array.indexOf(233) // 元素不存在，返回 -1

// 第二个参数表示从该索引位置（包括）向后查找
array.indexOf(20, 2) // =&gt; 3，因为是从 30 开始查找的 </code></pre>
<p>与之类似的<code>lastIndexOf()</code>则是从后开始查找，注意它返回的索引是不会改变的，依然是从左开始计数。</p>
<pre><code class="js">var array = [10, 20, 30, 20]
array.lastIndexOf(20) // =&gt; 3</code></pre>
<h3 id="unshift-push"><a href="#unshift-push" class="headerlink" title="unshift() / push()"></a>unshift() / push()</h3><p>在数组开头 / 末尾添加若干元素，会修改原数组。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>若干对象</td>
<td>要添加的元素</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数值</td>
<td>数组修改后的长度</td>
</tr>
</tbody></table>
<pre><code class="js">var array = [10]

array.unshift(6, 8) // =&gt; 3 
// array =&gt; [6, 8, 10]

array.push(20, 30) // =&gt; 3 
// array =&gt; [10, 20, 30]</code></pre>
<h3 id="shift-pop"><a href="#shift-pop" class="headerlink" title="shift() / pop()"></a>shift() / pop()</h3><p>删除数组第一个 / 最后一个元素，会修改原数组。</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>对象</td>
<td>删除的元素</td>
</tr>
</tbody></table>
<pre><code class="js">var array = [10, 20, 30]
array.shift() // =&gt; 10
// array =&gt; [20, 30]

array.pop() // =&gt; 30
// array =&gt; [10, 20]</code></pre>
<h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><p>删除从指定索引开始的若干元素（并添加新元素），会修改原数组。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数值</td>
<td>起始索引（包括）</td>
</tr>
<tr>
<td>数值</td>
<td>可选，要删除的元素数量，如果省略则删除起始索引之后的所有元素</td>
</tr>
<tr>
<td>若干对象</td>
<td>可选，删除元素后在起始索引处添加的新元素，如果省略则仅删除元素</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数组</td>
<td>删除的元素构成的数组，如果没有则返回空数组</td>
</tr>
</tbody></table>
<pre><code class="js">var array = [10, 20, 30, 40, 50]
array.splice(1, 2) // =&gt; [20, 30]
// array =&gt; [10, 40, 50]
array.splice(1, 2, 233) // =&gt; [20, 30]
// array =&gt; [10, 233, 40, 50]</code></pre>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><p>截取数组的一部分并返回，不会修改原数组。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数值</td>
<td>起始索引（包括），如果为负数则表示从后开始计数，最后一个元素的索引为<code>-1</code>，依次向前类推；如果省略则默认为<code>0</code></td>
</tr>
<tr>
<td>数值</td>
<td>结束索引（不包括），如果为负数则表示从后开始计数，最后一个元素的索引为<code>-1</code>，依次向前类推；如果省略则截取到数组最后</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数组</td>
<td>截取的数组</td>
</tr>
</tbody></table>
<pre><code class="js">var array = [10, 20, 30, 40]
array.slice(1) // =&gt; [20, 30, 40]
array.slice(1, 3) // =&gt; [20, 30]

array.slice(-2) // =&gt; [30, 40]
array.slice(-3, -1) // =&gt; [20, 30]</code></pre>
<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><p>将数组中的元素倒序排列，会修改原数组。</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数组</td>
<td>倒序的数组</td>
</tr>
</tbody></table>
<pre><code class="js">var array = [10, 20, 30, 40]
array.reverse() // =&gt; [40, 30, 20, 10]</code></pre>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><p>将数组按照一定规则排序，会修改原数组。注意，其默认的排序规则是 Unicode 码点，因此对于数值来说，它并不会比较数值的大小。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>函数</td>
<td>表示自定义排序规则。其两个参数表示数组的任意两个元素，通过比较后的返回值，可以决定排序规则。该函数写法比较固定，记住即可不必深究原理</td>
</tr>
</tbody></table>
<pre><code class="js">;[&#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;].sort() // =&gt; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]
;[13, 1, 77, 7].sort() // =&gt; [1, 13, 7, 77]

// 表示升序排列，return b - a 则表示降序
function rule(a, b) { return a - b }

;[10, 1000, 100].sort(rule) // =&gt; array: [10, 100, 1000]</code></pre>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><p>将一个数组（参数）追加到另一个数组（调用者）的后面，不会修改原数组。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数组</td>
<td>要追加的数组</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数组</td>
<td>合并后的新数组</td>
</tr>
</tbody></table>
<pre><code class="js">;[10, 20].concat([30, 40]) // =&gt; [10, 20, 30, 40]</code></pre>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p>遍历数组。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>函数</td>
<td>表示处理函数，它有三个参数，第一个表示当前元素，第二个表示当前索引，第三个表示遍历的数组本身</td>
</tr>
</tbody></table>
<pre><code class="js">var arr = [10, 20, 30]
arr.forEach(function (value, index, array) {
    value // 当前元素
    index // 当前元素的索引
    array // 数组对象
})</code></pre>
<h3 id="find-findIndex"><a href="#find-findIndex" class="headerlink" title="find() / findIndex()"></a>find() / findIndex()</h3><p>根据条件查找第一个匹配的元素 / 元素索引并返回：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>函数</td>
<td>表示处理函数，它有三个参数，第一个表示当前元素，第二个表示当前索引，第三个表示遍历的数组本身，返回值为判断条件</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>对象 / 数值</td>
<td>匹配的元素 / 元素索引</td>
</tr>
</tbody></table>
<pre><code class="js">var data = [
    { id: 1, name: &#39;Wendy&#39;},
    { id: 2, name: &#39;Lucy&#39;}
]

data.find(function (el, index, array) {
    return el.id == 1
}) // =&gt; { id: 1, name: &#39;Wendy&#39;}

data.findIndex(function (el, index, array) {
    return el.id == 1
}) // =&gt; 0</code></pre>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>根据条件过滤数组中的所有元素，将满足条件的元素放入一个新数组，不会影响原数组。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>函数</td>
<td>表示处理函数，它有三个参数，第一个表示当前元素，第二个表示当前索引，第三个表示遍历的数组本身，返回值为判断条件</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数组</td>
<td>满足条件元素组成的新数组</td>
</tr>
</tbody></table>
<pre><code class="js">var arr = [10, 5, 3, 0, 233, 666, 0]
arr.filter(function (value, index, array) {
    return value != 0
}) // =&gt; [10, 5, 3, 233, 666]</code></pre>
<h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><p>查找数组中是否有满足条件的元素，只要找到了符合条件的元素就会<strong>立刻终止遍历</strong>，不会继续判断后续的元素。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>函数</td>
<td>表示处理函数，它有三个参数，第一个表示当前元素，第二个表示当前索引，第三个表示遍历的数组本身，返回值为判断条件</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>布尔值</td>
<td>如果数组中包含满足条件的元素返回<code>true</code>，否则返回<code>false</code></td>
</tr>
</tbody></table>
<pre><code class="js">var arr = [10, 50, 100]
arr.some(function (value, index, array) {
    return value &gt; 50
}) // =&gt; true</code></pre>
<h3 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h3><p>查找数组中是否包含指定的元素。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>对象</td>
<td>要查找的元素</td>
</tr>
<tr>
<td>数值</td>
<td>可选，表示从该索引位置（包括）向后查找</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>布尔值</td>
<td>如果数组中包含指定元素返回<code>true</code>，否则返回<code>false</code></td>
</tr>
</tbody></table>
<pre><code class="js">;[10, 50, 100].includes(10) // =&gt; true</code></pre>
<h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p>以特定字符作为分隔符，将数组元素转换成一个字符串。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>表示分隔符，如果省略则默认为逗号，与直接使用数组调用<code>toString()</code>方法的结果相同</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>拼接后的字符串</td>
</tr>
</tbody></table>
<pre><code class="js">var array = [10, 20, 30]
array.join() // =&gt; &#39;10,20,30&#39;
array.join(&#39;|&#39;) // =&gt; &#39;10|20|30&#39;</code></pre>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><p>对数组中的某些数据进行累计，返回一个累计后的值。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>函数</td>
<td>迭代函数，包含最多以下四个参数：</td>
</tr>
<tr>
<td>子参数①</td>
<td>累计的结果值</td>
</tr>
<tr>
<td>子参数②</td>
<td>当前处理的数组元素</td>
</tr>
<tr>
<td>子参数③</td>
<td>可选，起始索引，如果提供了初始值，那么默认为<code>0</code>，否则为<code>1</code></td>
</tr>
<tr>
<td>子参数④</td>
<td>可选，调用该方法的数组</td>
</tr>
<tr>
<td>对象</td>
<td>可选，迭代的初始值，默认为数组的第一个元素</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>对象</td>
<td>累计之后的结果</td>
</tr>
</tbody></table>
<p>该方法可以依次取出数组元素，累计到结果值（子参数①）上。迭代函数的返回值表示本次的计算结果，迭代函数每次执行时，结果值均为上一次迭代的结果，通过与当前数组元素进行运算（不一定是加法，任何运算都可以），从而实现累计。</p>
<p>在下面的代码中，迭代函数首先取出数组的第一个元素<code>10</code>作为<code>sum</code>，取出第二个元素<code>20</code>作为<code>current</code>，然后将累加后的结果<code>30</code>作为返回值，保存到<code>sum</code>；第二次迭代时，取出上次的<code>sum</code>即<code>30</code>，取出第三个元素<code>40</code>作为<code>current</code>，将累加后的结果<code>70</code>作为返回值<code>sum</code>；此时迭代结束，将最后的<code>sum</code>即<code>70</code>作为方法的返回值。</p>
<pre><code class="js">[10, 20, 40].reduce(function (sum, current) {
    return sum + current
}) // =&gt; 70</code></pre>
<p>如果给出迭代函数之外的第二个参数，表示迭代的初始值。此时迭代函数会将该初始值作为<code>sum</code>，而不是数组的第一个元素；第一次迭代时也会变成取出数组的第一个元素。</p>
<pre><code class="js">[10, 20, 40].reduce(function (sum, current) {
    return sum + current
}, 0) // =&gt; 70</code></pre>
<p>两种方式的计算结果是一样的，区别在于，如果给出了初始值，那么迭代函数会多执行一次（因为第一次迭代只能取出第一个元素，否则可以一次取出两个）。不过还是建议总是给出初始值，因为如果传入了空数组，第一种方式会因为找不到初始值而报错。</p>
<pre><code class="js">[].reduce(function (sum, current) {
    return sum + current
}, 0) // =&gt; 0

[].reduce(function (sum, current) {
    return sum + current
}) // =&gt; TypeError: Reduce of empty array with no initial value</code></pre>
<p>下面的代码可以累加对象数组中的值：</p>
<pre><code class="js">let books = [
    { id: 1000, name: &#39;哈利波特&#39;, price: 300 },
    { id: 1001, name: &#39;北欧众神&#39;, price: 50 },
    { id: 1002, name: &#39;JOJO的奇妙冒险&#39;, price: 450 },
]

books.reduce(function(totalPrice, book){
    return totalPrice + book.price
}, 0) // =&gt; 800</code></pre>
<h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>将数组的每个元素调用处理函数之后，返回一个新数组。该方法不会修改原数组。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>函数</td>
<td>迭代函数，包含最多以下三个参数：</td>
</tr>
<tr>
<td>子参数①</td>
<td>当前数组元素</td>
</tr>
<tr>
<td>子参数②</td>
<td>可选，当前索引</td>
</tr>
<tr>
<td>子参数③</td>
<td>可选，调用该方法的数组</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数组</td>
<td>处理后的新数组</td>
</tr>
</tbody></table>
<pre><code class="js">[10, 20, 30].map(function (current, index, array) {
    return current * 2
}) // =&gt; [20, 40, 60]</code></pre>
<h3 id="from"><a href="#from" class="headerlink" title="from()"></a>from()</h3><p>静态方法，将一个伪数组或者类似数组的对象（只要包含<code>length</code>属性）转换为真正的数组。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>对象</td>
<td>要转换的对象</td>
</tr>
<tr>
<td>函数</td>
<td>可选，表示处理函数，可以对当前遍历的元素进行操作，它的参数为当前元素，返回值为要执行的操作</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数组</td>
<td>转换后的数组</td>
</tr>
</tbody></table>
<pre><code class="js">var obj = { 0: &#39;hello&#39;, 1: &#39;world&#39;, length: 2 }

Array.from(obj) // =&gt; [&#39;hello&#39;, &#39;world&#39;]
Array.from(obj, function (value) {
    return value += &#39;a&#39;
}) // =&gt; [&#39;helloa&#39;, &#39;worlda&#39;]</code></pre>
<h3 id="isArray"><a href="#isArray" class="headerlink" title="isArray()"></a>isArray()</h3><p>静态方法，判断一个值是否为数组。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>对象</td>
<td>要判断的值</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>布尔值</td>
<td>如果是数组则返回<code>true</code>，否则返回<code>false</code></td>
</tr>
</tbody></table>
<pre><code class="js">Array.isArray([1, 2, 3]) // =&gt; true</code></pre>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="indexOf-lastIndexOf-1"><a href="#indexOf-lastIndexOf-1" class="headerlink" title="indexOf() / lastIndexOf()"></a>indexOf() / lastIndexOf()</h3><p>获取一个字符串（参数）中的<strong>第一个字符</strong>在另一个字符串（调用者）中首次出现的位置。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>要查找的字符串</td>
</tr>
<tr>
<td>数值</td>
<td>可选，表示从该索引位置（包括）向后查找</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数值</td>
<td>参数在字符串中首次出现的索引位置，如果不存在返回<code>-1</code></td>
</tr>
</tbody></table>
<pre><code class="js">var str = &#39;helloworld&#39;
str.indexOf(&#39;o&#39;) // =&gt; 4
str.indexOf(&#39;world&#39;) // =&gt; 5
str.indexOf(&#39;Daisy&#39;) // =&gt; -1
str.indexOf(&#39;&#39;) // =&gt; 0
str.indexOf(&#39;o&#39;, 5) // =&gt; 6</code></pre>
<p>与之类似的<code>lastIndexOf()</code>则是从后开始查找，注意它返回的索引是不会改变的，依然是从左开始计数。</p>
<pre><code class="js">str.lastIndexOf(&#39;o&#39;) // =&gt; 6
str.indexOf(&#39;world&#39;) // =&gt; 5</code></pre>
<h3 id="charAt-charCodeAt"><a href="#charAt-charCodeAt" class="headerlink" title="charAt() / charCodeAt()"></a>charAt() / charCodeAt()</h3><p>获取字符串中某个位置的字符 / 字符编码。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数值</td>
<td>要查找的索引位置</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符串 / 数值</td>
<td>该索引位置的字符 / 字符编码</td>
</tr>
</tbody></table>
<pre><code class="js">var str = &#39;helloworld&#39;
str.charAt(5) // =&gt; &#39;w&#39;
str.charCodeAt(5) // =&gt; 119</code></pre>
<blockquote>
<p><code>charAt()</code>与字符串直接加方括号<code>[]</code>的效果相同，如<code>str.charAt(5)</code>等价于<code>str[5]</code>。</p>
</blockquote>
<h3 id="substring-slice"><a href="#substring-slice" class="headerlink" title="substring() / slice()"></a>substring() / slice()</h3><p>截取字符串，不会修改原字符串。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数值</td>
<td>起始索引（包括）</td>
</tr>
<tr>
<td>数值</td>
<td>结束索引（不包括），如果省略则截取到最后</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>截取后的字符串</td>
</tr>
</tbody></table>
<pre><code class="js">var str = &#39;helloworld&#39;
str.substring(5, 7) // =&gt; wo
str.substring(5) // =&gt; world
str.substring(-3, -1) // =&gt; rl</code></pre>
<blockquote>
<p>与之类似的<code>substr()</code>已经被废弃，不要使用。</p>
</blockquote>
<h3 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h3><p>替换字符串的一部分，不会修改原字符串。注意，该方法只能替换第一个匹配（除非使用全局匹配的正则）的内容。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符串或正则表达式</td>
<td>被替换的旧内容</td>
</tr>
<tr>
<td>字符串</td>
<td>新内容</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>替换后的字符串</td>
</tr>
</tbody></table>
<pre><code class="js">var str = &#39;hello123world123&#39;
str.replace(&#39;o&#39;, &#39;x&#39;) // =&gt; hellx123world123，将第一个 o 替换成 x
str.replace(/123/, &#39;x&#39;) // =&gt; helloxworld123，将第一个 123 替换成 x
str.replace(/123/g, &#39;x&#39;) // =&gt; helloxworldx，开启了全局匹配</code></pre>
<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><p>复制字符串，不会修改原字符串。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数值</td>
<td>复制的次数</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>复制后的字符串</td>
</tr>
</tbody></table>
<pre><code class="js">var str = &#39;hello&#39;
str.repeat(2) // =&gt; hellohello</code></pre>
<h3 id="trim"><a href="#trim" class="headerlink" title="trim()"></a>trim()</h3><p>去除字符串两端的空格，不会修改原字符串。</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>去除两端空格后的字符串</td>
</tr>
</tbody></table>
<pre><code class="js">&#39; hello world  &#39;.trim() // =&gt; &#39;hello world&#39;</code></pre>
<h3 id="startsWith-endsWith"><a href="#startsWith-endsWith" class="headerlink" title="startsWith() / endsWith()"></a>startsWith() / endsWith()</h3><p>判断字符串是否以指定内容开头 / 结尾。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>要判断的内容</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>布尔值</td>
<td>如果以指定内容开头 / 结尾返回<code>true</code>，否则返回<code>false</code></td>
</tr>
</tbody></table>
<pre><code class="js">var str = &#39;hello&#39;
str.startsWith(&#39;he&#39;) // =&gt; true
str.endsWith(&#39;lo&#39;) // =&gt; true</code></pre>
<h3 id="includes-1"><a href="#includes-1" class="headerlink" title="includes()"></a>includes()</h3><p>查找字符串中是否包含指定内容。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>要查找的内容</td>
</tr>
<tr>
<td>数值</td>
<td>可选，表示从该索引位置（包括）向后查找</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>布尔值</td>
<td>如果字符串中包含指定子串返回<code>true</code>，否则返回<code>false</code></td>
</tr>
</tbody></table>
<pre><code class="js">&#39;helloworld&#39;.includes(&#39;hello&#39;) // =&gt; true
&#39;helloworld&#39;.includes(&#39;&#39;) // =&gt; true，注意，空字符串也视为包含</code></pre>
<h3 id="padStart-padEnd"><a href="#padStart-padEnd" class="headerlink" title="padStart() / padEnd()"></a>padStart() / padEnd()</h3><p>当字符串长度不足时，以指定内容填充到字符串开头 / 末尾。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数值</td>
<td>目标长度</td>
</tr>
<tr>
<td>字符串</td>
<td>要填充的内容，如果填充后超过了目标长度，那么截断右侧多出的部分，默认值为<code>&#39;&#39;</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>填充后的新字符串</td>
</tr>
</tbody></table>
<pre><code class="js">&#39;hello&#39;.padStart(10) // =&gt; &#39;     hello&#39;
&#39;hello&#39;.padStart(10, &#39;a&#39;) // =&gt; &#39;aaaaahello&#39;
&#39;hello&#39;.padStart(10, &#39;1234567&#39;) // =&gt; &#39;12345hello&#39;</code></pre>
<h3 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h3><p>以某个字符作为分隔符，将字符串拆分为数组。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>表示分隔符，如果省略则相当于不拆分，如果为空字符串则拆分成单个字符</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数组</td>
<td>拆分后的数组</td>
</tr>
</tbody></table>
<pre><code class="js">var str = &#39;a|b|c&#39;
str.split() // =&gt; [&quot;a|b|c&quot;]
str.split(&#39;&#39;) // =&gt; [&quot;a&quot;, &quot;|&quot;, &quot;b&quot;, &quot;|&quot;, &quot;c&quot;]
str.split(&#39;|&#39;) // =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code></pre>
<h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><h3 id="toFixed"><a href="#toFixed" class="headerlink" title="toFixed()"></a>toFixed()</h3><p>设置小数的保留位数。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数值</td>
<td>要保留的位数，如果不传参数则<strong>四舍五入</strong>去掉小数位</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>字符串</strong></td>
<td>转换后的数值，注意它的类型</td>
</tr>
</tbody></table>
<pre><code class="js">var num = 9.876
num.toFixed() // =&gt; 10
num.toFixed(2) // =&gt; 9.88
num.toFixed(4) // =&gt; 9.8760</code></pre>
<h3 id="parseInt-parseFloat"><a href="#parseInt-parseFloat" class="headerlink" title="parseInt() / parseFloat()"></a>parseInt() / parseFloat()</h3><p>静态方法。将字符串转为整数（舍去小数位）/ 浮点数。它们会<strong>依次</strong>将每个字符转换为数字，直到遇到不能转为数字的字符，就不再继续，返回已经转换的部分。如果第一个字符就不能转化为数字（包括空字符串），返回<code>NaN</code>。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>要转换的值，如果不是字符串，那么会先调用<code>toString()</code>将该值转换成字符串</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数值</td>
<td>转换后的数值</td>
</tr>
</tbody></table>
<pre><code class="js">Number.parseInt(&#39;15px&#39;) // =&gt;15
Number.parseInt(&#39;abc&#39;) // =&gt; NaN</code></pre>
<blockquote>
<p>ES5 这两个方法位于<code>window</code>对象中，ES6 将其移动到了<code>Number</code>对象中。</p>
</blockquote>
<h3 id="isInteger"><a href="#isInteger" class="headerlink" title="isInteger()"></a>isInteger()</h3><p>判断一个值是否为整数。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>对象</td>
<td>要判断的值</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>布尔值</td>
<td>如果是整数则返回<code>true</code>，否则返回<code>false</code></td>
</tr>
</tbody></table>
<pre><code class="js">Number.isInteger(&#39;a&#39;) // =&gt; false</code></pre>
<h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><h3 id="abs"><a href="#abs" class="headerlink" title="abs()"></a>abs()</h3><p>静态方法。获取绝对值。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数值</td>
<td>要转换的值</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数值</td>
<td>转换后的绝对值</td>
</tr>
</tbody></table>
<pre><code class="js">Math.abs(-1) // =&gt; 1</code></pre>
<h3 id="max-min"><a href="#max-min" class="headerlink" title="max() / min()"></a>max() / min()</h3><p>静态方法。获取参数列表中的最大值 / 最小值。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>若干数值</td>
<td>要比较的值</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数值</td>
<td>参数列表的最大值 / 最小值</td>
</tr>
</tbody></table>
<pre><code class="js">Math.max(1, 5, 3) // =&gt; 5
Math.min(-1, -10) // =&gt; -1</code></pre>
<h3 id="floor-ceil-round"><a href="#floor-ceil-round" class="headerlink" title="floor() / ceil() / round()"></a>floor() / ceil() / round()</h3><p>将数值向下 / 向上 / 四舍五入取整。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数值</td>
<td>要取整的值</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数值</td>
<td>取整后的值</td>
</tr>
</tbody></table>
<pre><code class="js">Math.floor(3.2) // 3
Math.floor(-3.2) // -4

Math.ceil(3.2) // 4
Math.ceil(-3.2) // -3

Math.round(0.4) // 0
Math.round(0.5) // 1
Math.round(-1.5) // -1，注意负数时，也是向大数取整，因此 -2 -1.5 -1，取更大的 -1
Math.round(-1.6) // -2</code></pre>
<h3 id="random"><a href="#random" class="headerlink" title="random()"></a>random()</h3><p>获取一个$[0, 1)$之间的伪随机数。</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数值</td>
<td>随机数</td>
</tr>
</tbody></table>
<p>下面的函数可以返回一个$[min, max)$之间的<strong>随机数</strong>：</p>
<pre><code class="js">function getRandom(min, max) {
  return Math.random() * (max - min) + min
}

getRandom(1, 6)</code></pre>
<p>下面的函数可以返回一个$[min, max]$之间的<strong>随机整数</strong>：</p>
<pre><code class="js">function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min
}

getRandomInt(1, 6)</code></pre>
<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>使用构造函数<code>Date()</code>可以实例化一个日期对象：</p>
<pre><code class="js">new Date() // 创建一个当前时间的日期对象
new Date(&#39;1949-10-1 12:00:23&#39;) // 创建一个对应时间的日期对象</code></pre>
<p>日期对象覆盖了<code>toString()</code>方法，因此直接<code>console.log()</code>会打印一长串的时间信息。</p>
<pre><code class="js">console.log(new Date()) // =&gt; Sun Dec 22 2019 09:54:21 GMT+0800 (中国标准时间)</code></pre>
<p>但是这样的格式基本没法直接使用，因此还需要使用日期对象中的一系列方法来获取想要的数据：</p>
<pre><code class="js">var date = new Date(&#39;1949-10-1 12:00:23&#39;)
date.getFullYear()      // =&gt; 1949，获取年份
date.getMonth()         // =&gt; 9，注意月份是从 0 开始的，因此要得到正确的月份，请手动 +1
date.getDate()          // =&gt; 1，获取天
date.getDay()           // =&gt; 6，获取星期，注意周日为 0
date.getHours()         // =&gt; 12，获取小时数
date.getMinutes()       // =&gt; 0，获取分钟数
date.getSeconds()       // =&gt; 23，获取秒数
date.toLocaleString()   // =&gt; 1949/10/1 下午12:00:23，获取本地时间格式</code></pre>
<h3 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h3><p>JavaScript 的日期基于 Unix 时间戳（从世界协调时 1970 年 1 月 1 日开始经过的毫秒数），通过日期对象的下列方法可以获取它的时间戳：</p>
<pre><code class="js">var date = new Date(&#39;1949-10-1 12:00:23&#39;)
date.getTime() // =&gt; -639086377000
date.valueOf() // =&gt; -639086377000</code></pre>
<p>或者在实例化日期对象时使用一元运算符<code>+</code>将其转为<code>Number</code>型，这样也可以直接使该对象自动调用<code>valueOf()</code>方法，从而获取时间戳：</p>
<pre><code class="js">var timeStamp = +new Date(&#39;1949-10-1 12:00:23&#39;) // =&gt; -639086377000</code></pre>
<p>如果只是获取当前时间的时间戳，使用<code>Date</code>对象的静态方法<code>now()</code>即可：</p>
<pre><code class="js">var timeStamp = Date.now();</code></pre>
<h2 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h2><p>这里仅讨论正则表达式<code>RegExp</code>对象的相关方法，在这里查看<a href="/posts/9d8oxogs.html">正则表达式规则</a>。</p>
<p>使用两条斜杠<code>//</code>包裹创建一个正则表达式对象。</p>
<pre><code class="js">var regex = /hello/</code></pre>
<h3 id="test"><a href="#test" class="headerlink" title="test()"></a>test()</h3><p>验证字符串是否符合特定的正则表达式规则。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>要验证的字符串</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>布尔值</td>
<td>如果符合规则返回<code>true</code>，否则返回<code>false</code></td>
</tr>
</tbody></table>
<pre><code class="js">/hello/.test(&#39;helloworld&#39;) // =&gt; true</code></pre>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><p>获取匹配结果。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符串</td>
<td>要验证的字符串</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数组 / <code>null</code></td>
<td>如果匹配则以数组索引<code>0</code>返回匹配结果，否则返回<code>null</code></td>
</tr>
</tbody></table>
<p>如果正则表达式包含分组，则返回的数组会包括多个元素，其中索引<code>0</code>依然是整个匹配结果，而索引<code>1</code>之后则是每个单独分组匹配的结果。</p>
<pre><code class="js">var regex = /(\w+)@(\w+).(\w+)/
var arr = regex.exec(&#39;qingyibest@163.com&#39;)
// arr[0] =&gt; qingyibest@163.com
// arr[1] =&gt; qingyibest
// arr[2] =&gt; 163
// arr[3] =&gt; com</code></pre>
<p>此外，该数组还拥有两个属性，其中<code>index</code>表示成功匹配的第一个索引位置，<code>input</code>表示原字符串。</p>
<pre><code class="js">var arr = /e/.exec(&#39;hello&#39;)
// index =&gt; 1
// input =&gt; hello</code></pre>
<p>注意，如果字符串中有多个子字符串匹配，那么首次调用该方法只会返回第一个，要获取全部的结果，则需要使用循环遍历，且必须开启全局匹配。</p>
<pre><code class="js">var str = &#39;中国移动：10086；中国电信：10000；中国联通：10010&#39;
var regex = /[0-9]{5}/g
var arr1 = regex.exec(str)  // arr1[0] =&gt; 10086
var arr2 = regex.exec(str)  // arr2[0] =&gt; 10000
var arr3 = regex.exec(str)  // arr3[0] =&gt; 10010</code></pre>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>修饰符类似于正则对象的配置参数，它们定义在正则对象的<code>/</code>之后，且可以同时定义多个。</p>
<p>修饰符<code>g</code>表示全局匹配。默认情况下，当第一次找到符合规则的部分后，就不再继续向下匹配。开启全局匹配后表示查找整个字符串中全部符合规则的部分，主要用于搜索和替换。</p>
<pre><code class="js">&#39;helloworld&#39;.replace(/o/, &#39;x&#39;) // =&gt; hellxworld
&#39;helloworld&#39;.replace(/o/g, &#39;x&#39;) // =&gt; hellxwxrld</code></pre>
<p>修饰符<code>i</code>表示忽略大小写。</p>
<pre><code class="js">;/abc/.test(&#39;ABC&#39;) // =&gt; false
;/abc/i.test(&#39;ABC&#39;) // =&gt; true</code></pre>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON（JavaScript Object Notation，JavaScript 对象表示法）是现在非常流行的一种数据格式，它取代了之前常用的 XML，用来传输数据。它的主要格式规则如下：</p>
<ul>
<li>有大括号<code>{}</code>和方括号<code>[]</code>两种语法，大括号<code>{}</code>用来描述不同类型的无序键值对集合，方括号<code>[]</code>用来描述相同类型的有序数据集合</li>
<li>键名必须用<strong>双引号</strong>包裹</li>
<li>字符串必须用<strong>双引号</strong>包裹，不能用单引号</li>
<li>引用类型的值只能是数组或对象，不能是函数、日期等</li>
<li>基本类型的值只能是字符串、数值、布尔值或<code>null</code></li>
</ul>
<p>JavaScript 提供了内置对象<code>JSON</code>来操作 JSON 数据，它除了调用以下两个静态方法以外本身并没有其它作用。</p>
<pre><code class="js">// 下面是一些合法的 JSON
[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
{&quot;one&quot;: 1, &quot;two&quot;: 2, &quot;three&quot;: 3}
{&quot;names&quot;: [&quot;张三&quot;, &quot;李四&quot;]}
[{ &quot;name&quot;: &quot;张三&quot;}, {&quot;name&quot;: &quot;李四&quot;}]</code></pre>
<h3 id="stringify"><a href="#stringify" class="headerlink" title="stringify()"></a>stringify()</h3><p>将 JavaScript 对象转换为 JSON 字符串。</p>
<pre><code class="js">JSON.stringify({name: &quot;Lucy&quot;, weight: 15}) // =&gt; {&quot;name&quot;:&quot;Lucy&quot;,&quot;weight&quot;:15}
JSON.stringify([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]) // =&gt; [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</code></pre>
<h3 id="parse"><a href="#parse" class="headerlink" title="parse()"></a>parse()</h3><p>将 JSON 字符串转换为 JavaScript 对象。</p>
<pre><code class="js">JSON.parse(&#39;{&quot;name&quot;: &quot;Lucy&quot;, &quot;age&quot;: 18}&#39;) // =&gt; 对象 {name: &#39;Lucy&#39;, age: 18}
JSON.parse(&#39;[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&#39;) // =&gt; 数组 [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</code></pre>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>获取表示该对象类型的字符串。不过，由于 JavaScript 内置的多个对象（如数组、字符串、函数、日期等）都使用了自己的<code>toString()</code>将其覆盖，因此使用这些对象调用<code>toString()</code>时，会输出不一样的内容。</p>
<table>
<thead>
<tr>
<th>数据类型或对象</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td><code>Undefined</code></td>
<td><code>&#39;undefined&#39;</code></td>
</tr>
<tr>
<td><code>Null</code></td>
<td><code>&#39;null&#39;</code></td>
</tr>
<tr>
<td><code>Boolean</code></td>
<td><code>&#39;true&#39;</code>或者<code>&#39;false&#39;</code></td>
</tr>
<tr>
<td><code>Number</code></td>
<td>数值对应的字符串形式</td>
</tr>
<tr>
<td><code>Object</code></td>
<td><code>[object Object]</code></td>
</tr>
<tr>
<td>数组</td>
<td>以逗号分隔的元素，如<code>[1, 2, 3]</code>返回<code>1,2,3</code></td>
</tr>
<tr>
<td>函数</td>
<td>函数源代码</td>
</tr>
<tr>
<td>日期</td>
<td>如<code>Mon Sep 16 2019 17:01:43 GMT+0800 (中国标准时间)</code></td>
</tr>
</tbody></table>
<p>由于任何对象调用<code>toString()</code>方法默认会返回表示该对象类型的字符串，因此可以利用这一特性判断对象的数据类型。不过因为某些对象的<code>toString()</code>方法已经被覆盖，因此要通过<code>Object</code>来调用该方法，然后将要判断的对象作为<code>call()</code>的参数传进去。</p>
<pre><code class="js">var arr = [1, 2, 3]
Object.prototype.toString.call(arr) // =&gt; [object Array]</code></pre>
<p>常见对象的返回值如下，其它对象均返回<code>[object Object]</code>：</p>
<table>
<thead>
<tr>
<th>对象</th>
<th>返回值</th>
<th>对象</th>
<th>返回值</th>
<th>对象</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td><code>Number</code></td>
<td><code>[object Number]</code></td>
<td><code>String</code></td>
<td><code>[object String]</code></td>
<td><code>Boolean</code></td>
<td><code>[object Boolean]</code></td>
</tr>
<tr>
<td><code>Undefined</code></td>
<td><code>[object Undefined]</code></td>
<td><code>Null</code></td>
<td><code>[object Null]</code></td>
<td><code>Array</code></td>
<td><code>[object Array]</code></td>
</tr>
<tr>
<td><code>Arguments</code></td>
<td><code>[object Arguments]</code></td>
<td><code>Function</code></td>
<td><code>[object Function]</code></td>
<td><code>Date</code></td>
<td><code>[object Date]</code></td>
</tr>
</tbody></table>
<h3 id="keys"><a href="#keys" class="headerlink" title="keys()"></a>keys()</h3><p>获取一个对象的属性名，以数组形式返回。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>对象</td>
<td>要获取属性的对象</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数组</td>
<td>对象的属性名组成的数组</td>
</tr>
</tbody></table>
<pre><code class="js">var phone = { id: 1, pname: &#39;小米&#39;, price: 3999 }
Object.keys(obj) // =&gt; [id, pname, price]</code></pre>
<h2 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h2><h3 id="log"><a href="#log" class="headerlink" title="log()"></a>log()</h3><p>在控制台输出信息。</p>
<pre><code class="js">console.log(&#39;hello&#39;)</code></pre>
<p>注意，Chrome 浏览器在输出数组或对象类型时默认是折叠的，详细数据需要展开才能显示。但是，当展开数据时，浏览器会重新获取一次数据。也就是说，展开时看到的数据<strong>不一定</strong>是当时代码执行到<code>console.log()</code>处的结果。</p>
<h3 id="dir"><a href="#dir" class="headerlink" title="dir()"></a>dir()</h3><p>在控制台输出对象的所有属性和值。这种方式可以更加直观的看到对象的各种信息。</p>
<pre><code class="js">console.log({f1: &#39;foo&#39;, f2: &#39;bar&#39;}) // =&gt; {f1: &quot;foo&quot;, f2: &quot;bar&quot;}</code></pre>
</div>
    </div>
</div>

<div class="toc"></div>
    <footer>
    <p>© 2020</p>
    <p>Theme chicken by 小鸡米花, Powered by Hexo</p>
</footer>
    <a class="back-to-top" href="javascript:;"></a>

    <script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
    <script defer src="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.js"></script>
    <script defer src="https://cdn.staticfile.org/KaTeX/0.11.1/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, { strict: false, delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}] });"></script>
    <script src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js"></script>
    <script src="https://cdn.staticfile.org/highlight.js/9.18.1/highlight.min.js"></script>

    <script>
        // 为标签追加字体图标
        $('.tag-list-item').prepend('<span class="iconfont icon-biaoqian"></span>')

        // 回到顶部的猫
        $('.back-to-top').click(function () {
            $('html, body').animate({
                scrollTop: 0
            }, 500)
        })

        // 监听 回到顶部的猫 是否显示
        $(document).scroll(function () {
            if ($(document).scrollTop() > 50) {
                $('.back-to-top').addClass('show')
            } else {
                $('.back-to-top').removeClass('show')
            }
        })

        // 在表格外包裹一层，用来生成滚动条
        $('.post-content > table').wrap('<div class="table-container"></div>')

        // Tocbot 实例化，用来快速生成文档目录
        tocbot.init({
            tocSelector: '.toc', // 渲染目录的容器
            contentSelector: '.post-content', // 标题所在的容器
            headingSelector: 'h2, h3', // 要渲染的目录层级,
            headingsOffset: -50, // 微调目录高亮的显示位置（偏移量），防止点击的链接和高亮的链接不一致
        })

        // 初始化代码高亮 highlight.js
        hljs.initHighlightingOnLoad()

        // 自动加载 waifu
        try {
            $("<link>").attr({ href: "//cdn.yesuanzao.cn/blog/live2d/waifu.min.css", rel: "stylesheet", type: "text/css" }).appendTo('head');
            $('body').append('<div class="waifu"><div class="waifu-tips"></div><canvas id="live2d" class="live2d"></canvas><div class="waifu-tool"><span class="fui-home"></span> <span class="fui-chat"></span> <span class="fui-eye"></span> <span class="fui-user"></span> <span class="fui-photo"></span> <span class="fui-info-circle"></span> <span class="fui-cross"></span></div></div>');
            $.ajax({ url: '//cdn.yesuanzao.cn/blog/live2d/waifu-tips.js', dataType: "script", cache: false, async: false });
            $.ajax({ url: '//cdn.yesuanzao.cn/blog/live2d/live2d.min.js', dataType: "script", cache: false, async: false, complete: function() {
                initModel('//cdn.yesuanzao.cn/blog/live2d/waifu-tips.json');
            } });
        } catch (err) { console.log(err) }
    </script>
    <!-- 
        添加控制台，测试移动端
        <script src="http://cdn.jsdelivr.net/npm/eruda"></script>
        <script>eruda.init();</script>
    -->
</body>

</html>