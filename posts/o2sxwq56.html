<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>小鸡米花的知识库</title>
    <link rel="stylesheet" href="//cdn.yesuanzao.cn/blog/atom-one-dark.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css">
    <!-- 本地静态文件测试 -->
    <link rel="stylesheet" href="/css/chicken.css">
<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <header>
    <div class="container">
        <div class="site-title"><a href="/">小鸡米花的知识库</a></div>
        <nav>
            <a class="nav-item " href="/">主页</a>
            <a class="nav-item " href="/archives">时光轴</a>
        </nav>
    </div>
</header>
    <div id="write">
    <div class="container">
        <div class="post-info">
            <ul class="tag-list">
                
                    <a class="tag-list-item" href="/tags/JavaScript/">JavaScript</a>
                
            </ul>
        </div>
        <div class="post-content"><h1 id="🔔-JavaScript-标准库"><a href="#🔔-JavaScript-标准库" class="headerlink" title="🔔 JavaScript 标准库"></a>🔔 JavaScript 标准库</h1><p>收集了 JavaScript 中各种 API，需要时查阅即可。</p>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><h3 id="indexOf-lastIndexOf"><a href="#indexOf-lastIndexOf" class="headerlink" title="indexOf() / lastIndexOf()"></a>indexOf() / lastIndexOf()</h3><p>获取元素在数组中首次出现的索引位置。</p>
<pre><code class="js">let array = [10, 20, 30, 20]

array.indexOf(20)           // =&gt; 1
array.indexOf(233)          // =&gt; -1，元素不存在
array.indexOf(20, 2)        // =&gt; 3，第二个参数表示从该索引位置（包括）向后查找</code></pre>
<p><code>lastIndexOf()</code>用法一样，区别在于它是从后开始查找。注意它返回的索引是不会改变的，依然是从左开始计数。</p>
<pre><code class="js">array.lastIndexOf(20)       // =&gt; 3</code></pre>
<h3 id="unshift-push"><a href="#unshift-push" class="headerlink" title="unshift() / push()"></a>unshift() / push()</h3><p>在数组开头 / 末尾添加若干元素，返回修改后的数组长度，会修改原数组。</p>
<pre><code class="js">let array = [20]

array.unshift(0, 10)        // =&gt; 3，array: [0, 10, 20]
array.push(30, 40)          // =&gt; 3，array: [20, 30, 40]</code></pre>
<h3 id="shift-pop"><a href="#shift-pop" class="headerlink" title="shift() / pop()"></a>shift() / pop()</h3><p>删除数组第一个 / 最后一个元素，返回删除的元素，会修改原数组。</p>
<pre><code class="js">let array = [10, 20, 30]

array.shift()               // =&gt; 10，array: [20, 30]
array.pop()                 // =&gt; 30, array: [10, 20]</code></pre>
<h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><p>删除从指定索引开始的若干元素（并添加新元素），返回删除元素构成的数组（如果没有则返回空数组），会修改原数组。</p>
<p>它的第一个参数表示起始索引（包括）；第二个参数表示<strong>要删除的元素数量</strong>，省略则删除到最后；之后的所有参数表示删除元素后在起始索引处添加的新元素，省略则表示不添加新元素。</p>
<pre><code class="js">let array = [10, 20, 30, 40, 50]

array.splice(1, 2)              // =&gt; [20, 30]，array: [10, 40, 50]
array.splice(2)                 // =&gt; [30, 40, 50]，array: [10, 20]
array.splice(1, 2, 233)         // =&gt; [20, 30]，array: [10, 233, 40, 50]</code></pre>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><p>截取数组的一部分并返回，不修改原数组。</p>
<p>它的第一个参数表示起始索引（包括）；第二个参数表示结束索引（不包括），如果省略则截取到数组最后。负数索引表示从后开始计数，最后一个元素的索引为<code>-1</code>，依次向前类推。</p>
<pre><code class="js">let array = [10, 20, 30, 40, 50]

array.slice(1, 3)               // =&gt; [20, 30]
array.slice(1)                  // =&gt; [20, 30, 40, 50]
array.slice(1, -2)              // =&gt; [20, 30]
array.slice(-3)                 // =&gt; [30, 40, 50]</code></pre>
<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><p>将数组中的元素倒序排列，返回修改后的数组，会修改原数组。</p>
<pre><code class="js">[10, 20, 30].reverse()                 // =&gt; [30, 20, 10]</code></pre>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><p>将数组按照一定规则排序，返回排序后的数组，会修改原数组。注意，其默认的排序规则是 Unicode 码点，因此对于数值来说，它并不会比较数值的大小。</p>
<pre><code class="js">[&#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39;].sort()     // =&gt; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]
[13, 1, 77, 7].sort()           // =&gt; [1, 13, 7, 77]</code></pre>
<p>如果传入一个自定义函数，表示自定义排序规则，返回<code>a - b</code>表示升序排列，返回<code>b - a</code>表示降序排列。</p>
<pre><code class="js">[10, 1000, 100].sort((a, b) =&gt; {
    return a - b
})                              // =&gt; [10, 100, 1000]</code></pre>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><p>将两个数组合并为一个数组，返回合并后的数组，不会修改原数组。</p>
<pre><code class="js">[10, 20, 30].concat([40, 50])          // =&gt; [10, 20, 30, 40, 50]</code></pre>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p>遍历数组。</p>
<p>其三个参数中的<code>item</code>表示当前元素，<code>i</code>表示当前索引，<code>arr</code>表示调用方法的数组对象。</p>
<pre><code class="js">[10, 20, 30].forEach((item, i, arr) =&gt; {})</code></pre>
<h3 id="find-findIndex"><a href="#find-findIndex" class="headerlink" title="find() / findIndex()"></a>find() / findIndex()</h3><p>根据条件查找第一个匹配的元素 / 元素索引并返回。</p>
<p>其三个参数中的<code>item</code>表示当前元素，<code>i</code>表示当前索引，<code>arr</code>表示调用方法的数组对象。返回值为查询条件。</p>
<pre><code class="js">let data = [
    { id: 1, name: &#39;Wendy&#39;},
    { id: 2, name: &#39;Lucy&#39;}
]

data.find((item, i, arr) =&gt; {       
    return item.id === 1
})                                  // =&gt; { id: 1, name: &#39;Wendy&#39;}
data.findIndex((item, i, arr) =&gt; {  
    return item.id === 1
})                                  // =&gt; 0</code></pre>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>根据条件过滤数组中的所有元素，将满足条件的元素放入一个新数组并返回，不修改原数组。</p>
<p>其三个参数中的<code>item</code>表示当前元素，<code>i</code>表示当前索引，<code>arr</code>表示调用方法的数组对象。返回值为查询条件。</p>
<pre><code class="js">[10, 20, 30].filter((item, i, arr) =&gt; {
    return item !== 10
})                                  // =&gt; [20, 30]</code></pre>
<h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><p>查找数组中是否有满足条件的元素，只要找到了符合条件的元素就会<strong>立刻终止遍历</strong>，不会继续判断后续的元素。</p>
<p>其三个参数中的<code>item</code>表示当前元素，<code>i</code>表示当前索引，<code>arr</code>表示调用方法的数组对象。返回值为查询条件。</p>
<pre><code class="js">[10, 20, 30].some((item, i, arr) =&gt; {
    return value &gt; 10
})                                  // =&gt; true</code></pre>
<h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>将数组的每个元素调用处理函数之后，返回一个新数组。不修改原数组。</p>
<pre><code class="js">[10, 20, 30].map((item, i, arr) =&gt; {
    return item * 2
})                                  // =&gt; [20, 40, 60]</code></pre>
<h3 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h3><p>查找数组中是否包含指定的元素。如果传入第二个参数，表示从该索引位置（包括）向后查找。</p>
<pre><code class="js">[10, 20, 30].includes(10)                  // =&gt; true
[10, 20, 30].includes(10, 1)               // =&gt; false</code></pre>
<h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p>以特定字符作为分隔符，将数组元素转换成一个字符串。</p>
<pre><code class="js">[10, 20, 30].join()                        // =&gt; &#39;10,20,30&#39;，省略则默认为逗号
[10, 20, 30].join(&#39;|&#39;)                     // =&gt; &#39;10|20|30&#39;</code></pre>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><p>迭代数组。</p>
<p>它的第一个参数为迭代函数，其返回值表示本次迭代的结果，会被自动保存到<code>result</code>参数中，用于下一次迭代。当迭代完成后，迭代函数的返回值也会作为<code>reduce()</code>函数的返回值。</p>
<p>迭代函数最多有四个参数，第一个参数为</p>
<pre><code class="js">// 迭代数组中的元素并求和
[10, 20, 40].reduce(function (result, item, index, arr) {
    result  // 结果值，每次迭代的结果（函数返回值）都会保存于此，默认为数组的第一个元素
    item    // 当前元素
    index   // 起始索引，如果提供了初始值，那么默认为 0，否则为 1
    arr     // 数组对象: [10, 20, 40]
    return result + item
}) // =&gt; 70</code></pre>
<table>
<thead>
<tr>
<th>参数值</th>
<th>result</th>
<th>item</th>
<th>index</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>第一次迭代</td>
<td><code>10</code></td>
<td><code>20</code></td>
<td><code>1</code></td>
<td><code>10 + 20 = 30</code></td>
</tr>
<tr>
<td>第二次迭代</td>
<td><code>30</code></td>
<td><code>40</code></td>
<td><code>2</code></td>
<td><code>30 + 40 = 70</code></td>
</tr>
</tbody></table>
<p>如果给出迭代函数之外的第二个参数，表示迭代的初始值。第一次迭代时迭代函数的<code>result</code>参数会使用该初始值，而不是数组的第一个元素，并且<code>index</code>此时会默认为<code>0</code>，因此<code>item</code>也是数组的索引<code>0</code>元素，而非索引<code>1</code>元素。</p>
<pre><code class="js">[10, 20, 40].reduce(function (result, item, index) {
    return result + item
}, 0) // =&gt; 70</code></pre>
<table>
<thead>
<tr>
<th>参数值</th>
<th>result</th>
<th>item</th>
<th>index</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>第一次迭代</td>
<td><code>0</code></td>
<td><code>10</code></td>
<td><code>0</code></td>
<td><code>0 + 10 = 10</code></td>
</tr>
<tr>
<td>第二次迭代</td>
<td><code>10</code></td>
<td><code>20</code></td>
<td><code>1</code></td>
<td><code>10 + 20 = 30</code></td>
</tr>
<tr>
<td>第二次迭代</td>
<td><code>30</code></td>
<td><code>40</code></td>
<td><code>2</code></td>
<td><code>30 + 40 = 70</code></td>
</tr>
</tbody></table>
<p>两种方式的计算结果是一样的，区别在于，如果给出了初始值，那么迭代函数会多执行一次（因为第一次迭代只能取出第一个元素，否则可以一次取出两个）。不过还是建议总是给出初始值，因为如果传入了空数组，第一种方式会因为找不到初始值而报错。</p>
<h3 id="from"><a href="#from" class="headerlink" title="from()"></a>from()</h3><p>静态方法，将一个伪数组或者类似数组的对象（只要包含<code>length</code>属性）转换为真正的数组。</p>
<p>它的第一个参数为要转换的对象，第二个参数可以在转换的同时对每个元素进行操作。</p>
<pre><code class="js">var obj = { 0: &#39;hello&#39;, 1: &#39;world&#39;, length: 2 }

Array.from(obj)                     // =&gt; [&#39;hello&#39;, &#39;world&#39;]
Array.from(obj, item =&gt; {
    return item += &#39;a&#39;
})                                  // =&gt; [&#39;helloa&#39;, &#39;worlda&#39;]</code></pre>
<h3 id="isArray"><a href="#isArray" class="headerlink" title="isArray()"></a>isArray()</h3><p>静态方法，判断一个值是否为数组。</p>
<pre><code class="js">Array.isArray([1, 2, 3])            // =&gt; true</code></pre>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="indexOf-lastIndexOf-1"><a href="#indexOf-lastIndexOf-1" class="headerlink" title="indexOf() / lastIndexOf()"></a>indexOf() / lastIndexOf()</h3><p>获取子串的<strong>第一个字符</strong>在字符串中首次出现的位置。</p>
<pre><code class="js">let str = &#39;helloworld&#39;

str.indexOf(&#39;o&#39;)                // =&gt; 4
str.indexOf(&#39;world&#39;)            // =&gt; 5
str.indexOf(&#39;Daisy&#39;)            // =&gt; -1，子串不存在
str.indexOf(&#39;&#39;)                 // =&gt; 0
str.indexOf(&#39;o&#39;, 5)             // =&gt; 6</code></pre>
<p><code>lastIndexOf()</code>用法一样，区别在于它是从后开始查找。注意它返回的索引是不会改变的，依然是从左开始计数。</p>
<pre><code class="js">str.lastIndexOf(&#39;o&#39;)            // =&gt; 6</code></pre>
<h3 id="charAt-charCodeAt"><a href="#charAt-charCodeAt" class="headerlink" title="charAt() / charCodeAt()"></a>charAt() / charCodeAt()</h3><p>获取字符串中某个位置的字符 / 字符编码。</p>
<pre><code class="js">let str = &#39;helloworld&#39;

str.charAt(5)                   // =&gt; &#39;w&#39;，等价于 str[5]
str.charCodeAt(5)               // =&gt; 119</code></pre>
<h3 id="substring-slice"><a href="#substring-slice" class="headerlink" title="substring() / slice()"></a>substring() / slice()</h3><p>截取字符串，不修改原字符串。</p>
<p>它的第一个参数表示起始索引（包括），第二个参数表示结束索引（不包括），如果省略则截取到最后。</p>
<pre><code class="js">let str = &#39;helloworld&#39;

str.substring(5, 7)             // =&gt; wo
str.substring(5)                // =&gt; world
str.substring(-3, -1)           // =&gt; rl</code></pre>
<blockquote>
<p>与之类似的<code>substr()</code>已经被废弃，不要使用。</p>
</blockquote>
<h3 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h3><p>替换字符串的一部分，不修改原字符串。注意，该方法只能替换第一个匹配（除非使用全局匹配的正则）的内容。</p>
<pre><code class="js">let str = &#39;helloworld&#39;

str.replace(&#39;o&#39;, &#39;x&#39;)           // =&gt; hellxworld，将第一个 o 替换成 x
str.replace(/\w/, &#39;x&#39;)          // =&gt; xelloxworld，将第一个字母替换成 x
str.replace(/\w/g, &#39;x&#39;)         // =&gt; xxxxxxxxxx，开启了全局匹配</code></pre>
<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><p>复制字符串，不修改原字符串。</p>
<pre><code class="js">&#39;helloworld&#39;.repeat(2)          // =&gt; helloworldhelloworld</code></pre>
<h3 id="trim"><a href="#trim" class="headerlink" title="trim()"></a>trim()</h3><p>去除字符串两端的空格，不修改原字符串。</p>
<pre><code class="js">&#39; hello world  &#39;.trim()         // =&gt; &#39;hello world&#39;</code></pre>
<h3 id="startsWith-endsWith"><a href="#startsWith-endsWith" class="headerlink" title="startsWith() / endsWith()"></a>startsWith() / endsWith()</h3><p>判断字符串是否以指定内容开头 / 结尾。</p>
<pre><code class="js">let str = &#39;helloworld&#39;

str.startsWith(&#39;he&#39;)            // =&gt; true
str.endsWith(&#39;ld&#39;)              // =&gt; true</code></pre>
<h3 id="includes-1"><a href="#includes-1" class="headerlink" title="includes()"></a>includes()</h3><p>查找字符串中是否包含指定内容。如果传入第二个参数，表示从该索引位置（包括）向后查找。</p>
<pre><code class="js">let str = &#39;helloworld&#39;

str.includes(&#39;hello&#39;)           // =&gt; true
str.includes(&#39;hello&#39;, 1)        // =&gt; false
str.includes(&#39;&#39;)                // =&gt; true，空字符串也视为包含</code></pre>
<h3 id="padStart-padEnd"><a href="#padStart-padEnd" class="headerlink" title="padStart() / padEnd()"></a>padStart() / padEnd()</h3><p>当字符串长度不足时，以指定内容填充到字符串开头 / 末尾。</p>
<pre><code class="js">let str = &#39;hello&#39;

str.padStart(12)                // =&gt; &#39;  helloworld&#39;，默认填充空格
str.padStart(12, &#39;a&#39;)           // =&gt; &#39;aahelloworld&#39;，填充 a
str.padStart(12, &#39;1234567&#39;)     // =&gt; &#39;12helloworld&#39;，多余的指定内容会被截断
str.padEnd(12)                  // =&gt; &#39;helloworld  &#39;，在末尾填充，用法一样</code></pre>
<h3 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h3><p>以某个字符作为分隔符，将字符串拆分为字符串数组。</p>
<pre><code class="js">let str = &#39;a|b|c&#39;

str.split()                     // =&gt; [&#39;a|b|c&#39;]，没有参数，相当于不拆分
str.split(&#39;&#39;)                   // =&gt; [&#39;a&#39;, &#39;|&#39;, &#39;b&#39;, &#39;|&#39;, &#39;c&#39;]，空字符串，相当于全部拆分
str.split(&#39;|&#39;)                  // =&gt; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]，以竖线拆分</code></pre>
<h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><h3 id="toFixed"><a href="#toFixed" class="headerlink" title="toFixed()"></a>toFixed()</h3><p>设置小数的保留位数，如果要求位数比当前位数少，则<strong>四舍五入</strong>去除多余位数；反之，则在多余的位数补<code>0</code>。注意它的返回值为<strong>字符串</strong>类型。</p>
<pre><code class="js">let num = 9.876

num.toFixed()                   // =&gt; 10，不传参数表示去掉小数位
num.toFixed(2)                  // =&gt; 9.88
num.toFixed(4)                  // =&gt; 9.8760</code></pre>
<h3 id="parseInt-parseFloat"><a href="#parseInt-parseFloat" class="headerlink" title="parseInt() / parseFloat()"></a>parseInt() / parseFloat()</h3><p>静态方法。将字符串转为整数 / 浮点数。它们会<strong>依次</strong>将每个字符转换为数字，直到遇到不能转为数字的字符，就不再继续，返回已经转换的部分。如果第一个字符就不能转化为数字（包括空字符串），返回<code>NaN</code>。</p>
<pre><code class="js">Number.parseInt(&#39;15px&#39;)         // =&gt; 15
Number.parseInt(&#39;abc123&#39;)       // =&gt; NaN</code></pre>
<blockquote>
<p>ES5 这两个方法位于<code>window</code>对象中，ES6 将其移动到了<code>Number</code>对象中。</p>
</blockquote>
<h3 id="isInteger"><a href="#isInteger" class="headerlink" title="isInteger()"></a>isInteger()</h3><p>判断一个值是否为整数。</p>
<pre><code class="js">Number.isInteger(&#39;a&#39;)           // =&gt; false</code></pre>
<h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><h3 id="abs"><a href="#abs" class="headerlink" title="abs()"></a>abs()</h3><p>静态方法。获取绝对值。</p>
<pre><code class="js">Math.abs(-1)                // =&gt; 1</code></pre>
<h3 id="max-min"><a href="#max-min" class="headerlink" title="max() / min()"></a>max() / min()</h3><p>静态方法。获取参数列表中的最大值 / 最小值。</p>
<pre><code class="js">Math.max(1, 5, 3)           // =&gt; 5
Math.min(-1, -10)           // =&gt; -1</code></pre>
<h3 id="floor-ceil-round"><a href="#floor-ceil-round" class="headerlink" title="floor() / ceil() / round()"></a>floor() / ceil() / round()</h3><p>将数值向下 / 向上 / 四舍五入取整。</p>
<pre><code class="js">Math.floor(3.2)             // =&gt; 3
Math.floor(-3.2)            // =&gt; -4

Math.ceil(3.2)              // =&gt; 4
Math.ceil(-3.2)             // =&gt; -3

Math.round(0.4)             // =&gt; 0
Math.round(0.5)             // =&gt; 1
Math.round(-1.5)            // =&gt; -1，注意负数时，也是向大数取整，因此 -2 -1.5 -1，取更大的 -1
Math.round(-1.6)            // =&gt; -2</code></pre>
<h3 id="random"><a href="#random" class="headerlink" title="random()"></a>random()</h3><p>获取一个$[0, 1)$之间的伪随机数。</p>
<pre><code class="js">// 返回一个 [min, max) 之间的 随机数
function getRandom(min, max) {
    return Math.random() * (max - min) + min
}

// 返回一个 [min, max] 之间的 随机整数
function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min
}</code></pre>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><p>获取表示该对象类型的字符串。注意，由于一些内置对象（如数组、字符串、函数、日期等）使用了自己的<code>toString()</code>将其覆盖，因此使用这些对象调用<code>toString()</code>时，会输出不一样的内容。</p>
<table>
<thead>
<tr>
<th>数据类型或对象</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td><code>Undefined</code></td>
<td><code>&#39;undefined&#39;</code></td>
</tr>
<tr>
<td><code>Null</code></td>
<td><code>&#39;null&#39;</code></td>
</tr>
<tr>
<td><code>Boolean</code></td>
<td><code>&#39;true&#39;</code>或者<code>&#39;false&#39;</code></td>
</tr>
<tr>
<td><code>Number</code></td>
<td>数值对应的字符串形式</td>
</tr>
<tr>
<td><code>Object</code></td>
<td><code>[object Object]</code></td>
</tr>
<tr>
<td>数组</td>
<td>以逗号分隔的元素，如<code>[1, 2, 3]</code>返回<code>1,2,3</code></td>
</tr>
<tr>
<td>函数</td>
<td>函数源代码</td>
</tr>
<tr>
<td>日期</td>
<td>如<code>Mon Sep 16 2019 17:01:43 GMT+0800 (中国标准时间)</code></td>
</tr>
</tbody></table>
<h3 id="keys"><a href="#keys" class="headerlink" title="keys()"></a>keys()</h3><p>获取一个对象的属性名，以数组形式返回。</p>
<pre><code class="js">let phone = { id: 1, name: &#39;小米&#39;, price: 3999 }
Object.keys(obj) // =&gt; [&#39;id&#39;, &#39;name&#39;, &#39;price&#39;]</code></pre>
<h2 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h2><h3 id="log"><a href="#log" class="headerlink" title="log()"></a>log()</h3><p>在控制台输出信息。</p>
<pre><code class="js">console.log(&#39;hello&#39;)</code></pre>
<p>注意，Chrome 浏览器在输出数组或对象类型时默认是折叠的，详细数据需要展开才能显示。但是，当展开数据时，浏览器会重新获取一次数据。也就是说，展开时看到的数据<strong>不一定</strong>是当时代码执行到<code>console.log()</code>处的结果。</p>
<h3 id="dir"><a href="#dir" class="headerlink" title="dir()"></a>dir()</h3><p>在控制台输出对象的所有属性和值。这种方式可以更加直观的看到对象的各种信息。</p>
<pre><code class="js">console.log({ f1: &#39;foo&#39;, f2: &#39;bar&#39; }) // =&gt; { f1: &#39;foo&#39;, f2: &#39;bar&#39; }</code></pre>
</div>
    </div>
</div>

<div class="toc"></div>
    <footer>
    <p>© 2020</p>
    <p>Theme chicken by 小鸡米花, Powered by Hexo</p>
</footer>
    <a class="back-to-top" href="javascript:;"></a>

    <script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
    <script defer src="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.js"></script>
    <script defer src="https://cdn.staticfile.org/KaTeX/0.11.1/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, { strict: false, delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}] });"></script>
    <script src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js"></script>
    <script src="https://cdn.staticfile.org/highlight.js/9.18.1/highlight.min.js"></script>

    <script>
        // 为标签追加字体图标
        $('.tag-list-item').prepend('<i class="fas fa-tag"></i>')

        // 回到顶部的猫
        $('.back-to-top').click(function () {
            $('html, body').animate({
                scrollTop: 0
            }, 500)
        })

        // 监听 回到顶部的猫 是否显示
        $(document).scroll(function () {
            if ($(document).scrollTop() > 50) {
                $('.back-to-top').addClass('show')
            } else {
                $('.back-to-top').removeClass('show')
            }
        })

        // 在表格外包裹一层，用来生成滚动条
        $('.post-content > table').wrap('<div class="table-container"></div>')

        // Tocbot 实例化，用来快速生成文档目录
        tocbot.init({
            tocSelector: '.toc', // 渲染目录的容器
            contentSelector: '.post-content', // 标题所在的容器
            headingSelector: 'h2, h3', // 要渲染的目录层级,
            headingsOffset: -50, // 微调目录高亮的显示位置（偏移量），防止点击的链接和高亮的链接不一致
        })

        // 初始化代码高亮 highlight.js
        hljs.initHighlightingOnLoad()

        // 自动加载 waifu
        try {
            $("<link>").attr({ href: "//cdn.yesuanzao.cn/blog/live2d/waifu.min.css", rel: "stylesheet", type: "text/css" }).appendTo('head');
            $('body').append('<div class="waifu"><div class="waifu-tips"></div><canvas id="live2d" class="live2d"></canvas><div class="waifu-tool"><span class="fui-home"></span> <span class="fui-chat"></span> <span class="fui-eye"></span> <span class="fui-user"></span> <span class="fui-photo"></span> <span class="fui-info-circle"></span> <span class="fui-cross"></span></div></div>');
            $.ajax({ url: '//cdn.yesuanzao.cn/blog/live2d/waifu-tips.js', dataType: "script", cache: true, async: false });
            $.ajax({ url: '//cdn.yesuanzao.cn/blog/live2d/live2d.min.js', dataType: "script", cache: true, async: false, success: function() {
                initModel('//cdn.yesuanzao.cn/blog/live2d/waifu-tips.json');
            } });
        } catch (err) { console.log(err) }
    </script>
    <!-- 
        添加控制台，测试移动端
        <script src="http://cdn.jsdelivr.net/npm/eruda"></script>
        <script>eruda.init();</script>
    -->
</body>

</html>