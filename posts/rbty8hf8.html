<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>这是一个神奇的主题</title>
    <!-- <link rel="stylesheet" href="/css/chicken.css"> -->
    <link rel="stylesheet" href="//cdn.yesuanzao.cn/chicken.css">
    <link rel="stylesheet" href="/css/iconfont.css">
    <link rel="stylesheet" href="//cdn.yesuanzao.cn/blog/atom-one-dark.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.css">
    <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css">
<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <header>
    <div class="container">
        <div class="site-title"><a href="/">小鸡米花的知识库</a></div>
        <nav>
            <a class="nav-item " href="/">主页</a>
            <a class="nav-item " href="/archives">时光轴</a>
        </nav>
    </div>
</header>
    <div id="write">
    <div class="container">
        <div class="post-info">
            <ul class="tag-list">
                
                    <a class="tag-list-item" href="/tags/CSS/">CSS</a>
                
            </ul>
        </div>
        <div class="post-content"><h1 id="🏢-CSS-布局"><a href="#🏢-CSS-布局" class="headerlink" title="🏢 CSS 布局"></a>🏢 CSS 布局</h1><p>默认情况下，元素都位于普通文档流中，此时元素会按照从上到下、从左到右依次排列。但是通过下面的方式，可以修改元素的排列方式。</p>
<h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><p>浮动原本是用来修改文章中图片位置的，但是它经常被误用于布局中，用来使多个元素排列在一行。</p>
<p>使用<code>float</code>可以设置元素浮动。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>所有元素</td>
<td>不可继承</td>
<td><code>none</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code></td>
<td>不浮动</td>
</tr>
<tr>
<td><code>left</code></td>
<td>左浮动</td>
</tr>
<tr>
<td><code>right</code></td>
<td>右浮动</td>
</tr>
</tbody></table>
<p>浮动的元素会部分脱离文档流，具体来说，它有以下几个特征：</p>
<p><strong>首先，块级元素看不到浮动元素，会沉到浮动元素下层。</strong></p>
<p><img src="http://cdn.yesuanzao.cn/superbed/2020/01/23/5e28d1232fb38b8c3c2a0f24.jpg" alt=""></p>
<pre><code class="html">&lt;div class=&quot;float-box&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;block-box&quot;&gt;&lt;/div&gt;</code></pre>
<pre><code class="css">.float-box { float: left; }</code></pre>
<p><strong>然后，行内元素或行内块元素可以看到浮动元素，会环绕在浮动元素周围。</strong></p>
<p><img src="http://cdn.yesuanzao.cn/superbed/2020/01/23/5e28d2372fb38b8c3c2a2fe9.jpg" alt=""></p>
<pre><code class="html">&lt;div class=&quot;float-box&quot;&gt;&lt;/div&gt;
&lt;span class=&quot;inline-box&quot;&gt;啦啦啦&lt;/span&gt;</code></pre>
<pre><code class="css">.float-box { float: left; }</code></pre>
<p><strong>但是，浮动元素能看到文档流中的所有元素，避开块级元素排列到它们下方，避开行内元素排列到它们左侧或右侧。</strong></p>
<p><img src="http://cdn.yesuanzao.cn/superbed/2020/01/23/5e28d3a42fb38b8c3c2ae436.jpg" alt=""></p>
<pre><code class="html">&lt;div class=&quot;block-box&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;float-box&quot;&gt;&lt;/div&gt;</code></pre>
<pre><code class="css">.float-box { float: left; }</code></pre>
<p>除了脱离文档流之外，它还有下面一些其它特性：</p>
<ul>
<li>如果没有为元素设置<code>width</code>，那么浮动元素会根据内容收缩</li>
<li>会自动拥有<strong>行内块元素</strong>的一些特性，可以定义宽度高度，也可以与其它元素排成一行</li>
<li><code>margin</code>的<code>auto</code>值无效</li>
</ul>
<h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>使用<code>clear</code>可以避免文档流中后面的<strong>块级元素</strong>沉到浮动元素下层，使其排列到浮动元素下方，而不是与它重叠在一起。也就是说，可以让块级元素看到浮动元素。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>块级元素</td>
<td>不可继承</td>
<td><code>none</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>none</code></td>
<td>不清除浮动</td>
</tr>
<tr>
<td><code>both</code></td>
<td>避开两侧的浮动元素，排列到它们下方</td>
</tr>
</tbody></table>
<p><img src="http://cdn.yesuanzao.cn/superbed/2020/01/23/5e28d5982fb38b8c3c2b07bf.jpg" alt=""></p>
<pre><code class="html">&lt;div class=&quot;float-box&quot;&gt;&lt;/div&gt;
&lt;div class=&quot;block-box&quot;&gt;&lt;/div&gt;</code></pre>
<pre><code class="css">.float-box { float: left; }
.block-box { clear: both; }</code></pre>
<h3 id="高度塌陷"><a href="#高度塌陷" class="headerlink" title="高度塌陷"></a>高度塌陷</h3><p>如果一个块级元素没有设置高度，并且只包含浮动元素，那么会导致它无法获得子元素高度，从而高度为<code>0</code>，这称为浮动元素引起的高度塌陷。</p>
<p>在下面的代码中，虽然浮动元素自身有高度，但是父元素的高度依然为<code>0</code>，导致后面的元素直接将该元素覆盖。</p>
<pre><code class="html">&lt;div class=&quot;container&quot;&gt;
    &lt;div class=&quot;float-box&quot;&gt;&lt;/div&gt;
&lt;/div&gt;</code></pre>
<pre><code class="css">.float-box { 
    float: left;
    height: 200px; 
}</code></pre>
<p>使用<code>clear</code>可以解决这个问题，只需在父元素中通过伪元素<code>::after</code>追加一个清除浮动的<strong>块级元素</strong>即可：</p>
<pre><code class="css">.container::after {
    display: block; /* clear 只能应用于块级元素 */
    content: &quot;&quot;; /* 伪元素必须有 content 才能生效 */
    clear: both;
}</code></pre>
<p>除此之外，也可以使用触发父元素<a href="/posts/9obo9xpo.html">BFC</a>的方式避免高度塌陷。</p>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>使用<code>position</code>设置元素定位。对于绝对定位和固定定位元素来说，它们会变成块级元素，并且即便<a href="/posts/vv37590w.html">包含块</a>没有定义具体高度，<code>height: 100%</code>这样的属性也可以生效。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>所有元素</td>
<td>不可继承</td>
<td><code>static</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>static</code></td>
<td>不定位</td>
</tr>
<tr>
<td><code>relative</code></td>
<td>相对定位，使元素相对于<strong>原本位置</strong>进行偏移，并且之前的位置依然会被<strong>保留</strong></td>
</tr>
<tr>
<td><code>absolute</code></td>
<td>绝对定位，使元素从文档流中被<strong>完全移除</strong>，它的位置仅受<a href="/posts/vv37590w.html">包含块</a>以及偏移量影响</td>
</tr>
<tr>
<td><code>fixed</code></td>
<td>固定定位，与绝对定位的唯一不同是，它的<a href="/posts/vv37590w.html">包含块</a>是浏览器窗口</td>
</tr>
</tbody></table>
<h3 id="偏移量"><a href="#偏移量" class="headerlink" title="偏移量"></a>偏移量</h3><p>使用<code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>设置定位元素的偏移量，即相对于<a href="/posts/vv37590w.html">包含块</a>某个方向的距离。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>定位元素</td>
<td>不可继承</td>
<td><code>auto</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code></td>
<td>见<a href="/posts/vv37590w.html">包含块</a>一节</td>
</tr>
<tr>
<td>长度值</td>
<td>设置具体的偏移量</td>
</tr>
<tr>
<td>百分比值</td>
<td>水平方向相对于<a href="/posts/vv37590w.html">包含块</a>的<code>width</code>，垂直方向相对于<a href="/posts/vv37590w.html">包含块</a>的<code>height</code></td>
</tr>
</tbody></table>
<h3 id="层叠位置"><a href="#层叠位置" class="headerlink" title="层叠位置"></a>层叠位置</h3><p>由于定位后的元素可能会相互重叠，使用<code>z-index</code>属性可以设置在同一个<a href="/posts/xsvc751j.html">层叠上下文</a>中哪个元素显示在上层。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>定位元素</td>
<td>不可继承</td>
<td><code>auto</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code></td>
<td>如果只有一个<a href="/posts/xsvc751j.html">层叠上下文</a>的话，相当于<code>0</code></td>
</tr>
<tr>
<td>整数值</td>
<td>数值越大，元素越靠近上层，可以为负数</td>
</tr>
</tbody></table>
<h2 id="弹性布局"><a href="#弹性布局" class="headerlink" title="弹性布局"></a>弹性布局</h2><p>弹性布局是 CSS3 新增的一种非常强大的布局方式，但是由于兼容性问题，目前主要使用在移动端。</p>
<p>使用<code>display: flex</code>或者<code>display: inline-flex</code>将元素变成<strong>弹性容器</strong>，其中的<strong>直接</strong>子元素则会自动变成<strong>弹性项目</strong>。</p>
<pre><code class="html">&lt;div class=&quot;box&quot;&gt;
    &lt;div class=&quot;item&quot;&gt;我是项目1号&lt;/div&gt;
    &lt;span class=&quot;item&quot;&gt;我是项目2号&lt;/span&gt;
    &lt;p class=&quot;item&quot;&gt;我是项目3号&lt;/p&gt;
&lt;/div&gt;</code></pre>
<pre><code class="css">.box { display: flex; }</code></pre>
<p>虽然容器中的元素原本不同，但是现在它们都变成了项目，除了元素自带的样式外，它们都是一样的。这时项目的一些属性会失效，比如<code>float</code>、<code>vertical-align</code>或者<code>display: block</code>等。</p>
<p>容器有两根轴，分别为<strong>主轴</strong>和<strong>交叉轴</strong>，其中的项目会依次沿主轴排列，默认<strong>从左到右</strong>。将主轴<strong>顺时针旋转90°</strong>就得到了交叉轴，因此交叉轴默认<strong>从上到下</strong>。</p>
<h3 id="主轴方向"><a href="#主轴方向" class="headerlink" title="主轴方向"></a>主轴方向</h3><p>使用<code>flex-direction</code>设置主轴方向，注意这会导致<strong>交叉轴同时被旋转</strong>。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>弹性容器</td>
<td>不可继承</td>
<td><code>row</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>row</code></td>
<td>从左到右</td>
</tr>
<tr>
<td><code>row-reverse</code></td>
<td>从右到左</td>
</tr>
<tr>
<td><code>column</code></td>
<td>从上到下</td>
</tr>
<tr>
<td><code>column-reverse</code></td>
<td>从下到上</td>
</tr>
</tbody></table>
<p><img src="https://pic3.superbed.cn/item/5dfae7d276085c3289ba06b8.jpg" alt=""></p>
<h3 id="主轴对齐"><a href="#主轴对齐" class="headerlink" title="主轴对齐"></a>主轴对齐</h3><p>使用<code>justify-content</code>设置项目在主轴上的对齐方式。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>弹性容器</td>
<td>不可继承</td>
<td><code>flex-start</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>flex-start</code></td>
<td>左对齐（主轴的起点）</td>
</tr>
<tr>
<td><code>flex-end</code></td>
<td>右对齐（主轴的末尾）</td>
</tr>
<tr>
<td><code>center</code></td>
<td>居中对齐</td>
</tr>
<tr>
<td><code>space-between</code></td>
<td>两端对齐，项目之间的距离相等</td>
</tr>
<tr>
<td><code>space-around</code></td>
<td>项目两侧的距离相等</td>
</tr>
</tbody></table>
<p><img src="https://pic.superbed.cn/item/5dfae8e676085c3289ba3409.jpg" alt=""></p>
<h3 id="交叉轴对齐"><a href="#交叉轴对齐" class="headerlink" title="交叉轴对齐"></a>交叉轴对齐</h3><p>使用<code>align-items</code>和<code>align-self</code>设置所有项目 / 单个项目在交叉轴上的对齐方式。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>弹性容器</td>
<td>不可继承</td>
<td><code>stretch</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>stretch</code></td>
<td>拉伸至容器的高度（交叉轴对应的方向）。如果项目设置了高度，则该属性值无效</td>
</tr>
<tr>
<td><code>flex-start</code></td>
<td>顶部对齐（交叉轴的起点）</td>
</tr>
<tr>
<td><code>flex-end</code></td>
<td>底部对齐（交叉轴的末尾）</td>
</tr>
<tr>
<td><code>center</code></td>
<td>居中对齐</td>
</tr>
<tr>
<td><code>baseline</code></td>
<td>基线对齐，以项目内的第一行文本为准</td>
</tr>
</tbody></table>
<p><img src="https://pic2.superbed.cn/item/5dfaeb4376085c3289ba9671.jpg" alt=""></p>
<h3 id="主轴剩余空间分配"><a href="#主轴剩余空间分配" class="headerlink" title="主轴剩余空间分配"></a>主轴剩余空间分配</h3><p>如果项目的宽度总和不能填满主轴的宽度，那么多余的空间保留会被保留，使用<code>flex-grow</code>属性可以设置这些<strong>剩余空间</strong>如何分配。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>弹性容器</td>
<td>不可继承</td>
<td><code>0</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数字值</td>
<td>表示分配给该项目的剩余空间比例。设置为<code>0</code>表示该项目不分配剩余空间，保持原来大小；所有项目均为同一个<code>&gt;= 1</code>的数，那么表示所有项目<strong>等分剩余空间</strong>；如果它们不为同一个数，则按照数值的比例进行分配</td>
</tr>
</tbody></table>
<p><img src="https://pic.superbed.cn/item/5dfaeca076085c3289bad146.jpg" alt=""></p>
<p>如果项目的宽度总和超过了填满主轴的宽度，那么剩余空间为负，使用<code>flex-shrink</code>属性可以设置这些<strong>负的剩余空间</strong>如何分配。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>弹性容器</td>
<td>不可继承</td>
<td><code>1</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>数字值</td>
<td>表示分配给该项目的剩余空间比例。设置为<code>0</code>表示空间不足时该项目不会缩小自身，如果所有项目均设置为<code>0</code>，那么它们会超出容器；所有项目均为同一个<code>&gt;= 1</code>的数，那么表示项目以相同比例缩小；如果它们不为同一个数，则按照数值的比例进行分配</td>
</tr>
</tbody></table>
<p>注意，即使项目设置了宽度<code>width</code>，当剩余空间不足时，这些项目也会被缩小。如果不希望它们的宽度被改变，那么将其设置为<code>flex-shrink: 0</code>。</p>
<h3 id="自动换行"><a href="#自动换行" class="headerlink" title="自动换行"></a>自动换行</h3><p>使用<code>flex-wrap</code>设置当主轴空间不足时，项目自动换行。该属性的优先级比项目缩小要高，如果一行下不能容纳所有元素，那么会优先换行而不是缩小元素。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>弹性容器</td>
<td>不可继承</td>
<td><code>nowrap</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>nowrap</code></td>
<td>不换行</td>
</tr>
<tr>
<td><code>wrap</code></td>
<td>允许项目自动换行</td>
</tr>
</tbody></table>
<p><img src="https://pic3.superbed.cn/item/5dfaeed876085c3289bb3391.jpg" alt=""></p>
<h3 id="多行对齐"><a href="#多行对齐" class="headerlink" title="多行对齐"></a>多行对齐</h3><p>使用<code>align-content</code>设置当发生换行时，行的排列方式。如果容器只有一行，或者不允许自动换行，那么该属性无效。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>弹性容器</td>
<td>不可继承</td>
<td><code>stretch</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>stretch</code></td>
<td>拉伸到当前行高度最大项目的高度</td>
</tr>
<tr>
<td><code>flex-start</code></td>
<td>顶端对齐（交叉轴的起点）</td>
</tr>
<tr>
<td><code>flex-end</code></td>
<td>底部对齐（交叉轴的终点）</td>
</tr>
<tr>
<td><code>center</code></td>
<td>居中对齐</td>
</tr>
<tr>
<td><code>space-between</code></td>
<td>两端对齐，行之间的距离相等</td>
</tr>
<tr>
<td><code>space-around</code></td>
<td>行两侧的距离相等</td>
</tr>
</tbody></table>
<p><img src="https://pic2.superbed.cn/item/5dfaee5d76085c3289bb1ed6.jpg" alt=""></p>
<h2 id="表格布局"><a href="#表格布局" class="headerlink" title="表格布局"></a>表格布局</h2><p>表格是 CSS 中类似于传统 HTML 表格的布局方式。使用<code>display</code>属性可以将元素设置为表格样式：</p>
<ul>
<li><code>table</code>：块级表格，等同于<code>&lt;table&gt;</code>标签</li>
<li><code>inline-table</code>：行内块表格，等同于<code>&lt;table&gt;</code>标签，并设置为<code>inline-block</code></li>
<li><code>table-row</code>：定义行，等同于<code>&lt;tr&gt;</code>标签</li>
<li><code>table-cell</code>：定义单元格，等同于<code>&lt;td&gt;</code>或<code>&lt;th&gt;</code>标签</li>
</ul>
<h3 id="表格边框模型"><a href="#表格边框模型" class="headerlink" title="表格边框模型"></a>表格边框模型</h3><p>使用<code>border-collapse</code>设置表格的边框模型。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>表格元素</td>
<td>可继承</td>
<td><code>separate</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>separate</code></td>
<td>分离边框模型，单元格之间彼此分开，产生一定的缝隙，每个单元格有自己独立的边框</td>
</tr>
<tr>
<td><code>collapse</code></td>
<td>折叠边框模型，单元格之间的缝隙完全清除，相邻的单元格共用一条边框</td>
</tr>
</tbody></table>
<p>不同的边框模型会导致表格元素的部分盒模型属性失效：</p>
<table>
<thead>
<tr>
<th></th>
<th>表格（分离）</th>
<th>表格（折叠）</th>
<th>行（分离）</th>
<th>行（折叠）</th>
<th>单元格（分离）</th>
<th>单元格（折叠）</th>
</tr>
</thead>
<tbody><tr>
<td><code>margin</code></td>
<td>✔️</td>
<td>✔️</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td><code>border</code></td>
<td>✔️</td>
<td>✔️</td>
<td>❌</td>
<td>✔️</td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td><code>padding</code></td>
<td>✔️</td>
<td>❌</td>
<td>❌</td>
<td>❌</td>
<td>✔️</td>
<td>✔️</td>
</tr>
</tbody></table>
<p>如果使用了折叠边框模型，但是相邻单元格或行的边框不同，那么会采用下面的规则决定边框的优先级：</p>
<ul>
<li>如果边框为<code>border-style: hidden</code>，那么优先级最高</li>
<li>如果边框都是可见的，那么宽度更大的边框优先</li>
<li>如果边框宽度相同，那么按照边框样式排序，优先级由高到低为<code>double</code>、<code>solid</code>、<code>dashed</code>、<code>dotted</code>、<code>ridge</code>、<code>outset</code>、<code>groove</code>、<code>inset</code>、<code>none</code></li>
<li>如果样式和宽度都相同，但颜色不同，那么优先级由高到低为单元格、行、列、表。如果两个元素都是单元格，那么位置更靠近<strong>右下</strong>的优先</li>
</ul>
<h3 id="单元格间距"><a href="#单元格间距" class="headerlink" title="单元格间距"></a>单元格间距</h3><p>使用<code>border-spacing</code>设置单元格的间距，即单元格边框到表格内边距，以及相邻单元格之间的距离。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>分离边框模型的表格元素</td>
<td>可继承</td>
<td><code>0</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>长度值</td>
<td>设置具体的距离，如果只有一个值则同时表示水平和垂直方向；如果有两个值，则前者表示水平方向，后者表示垂直方向</td>
</tr>
</tbody></table>
<pre><code class="css">table { 
    padding: 20px;
    border-spacing: 20px; 
}  </code></pre>
<p><img src="http://cdn.yesuanzao.cn/superbed/2020/01/23/5e28e87c2fb38b8c3c2e14e2.jpg" alt=""></p>
<h3 id="空单元格"><a href="#空单元格" class="headerlink" title="空单元格"></a>空单元格</h3><p>使用<code>empty-cell</code>设置空单元格的处理方式。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>分离边框模型的表格元素</td>
<td>可继承</td>
<td><code>show</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>show</code></td>
<td>如果单元格为空，它的边框和背景依然会正常显示</td>
</tr>
<tr>
<td><code>hide</code></td>
<td>如果单元格为空，隐藏其边框和背景</td>
</tr>
</tbody></table>
<h3 id="宽度计算"><a href="#宽度计算" class="headerlink" title="宽度计算"></a>宽度计算</h3><p>使用<code>table-layout</code>设置表格宽度的计算方式。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>表格元素</td>
<td>可继承</td>
<td><code>auto</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code></td>
<td>自动宽度布局，表格的宽度根据内容自动计算。此时表格的<code>width</code>相当于<code>min-width</code>，也就是说如果内容过多的话，浏览器会尽量将内容压缩，并忽略<code>width</code></td>
</tr>
<tr>
<td><code>fixed</code></td>
<td>固定宽度布局，表格的宽度与内容无关。如果表格的<code>width</code>为<code>auto</code>（默认值），那么浏览器会强制使用自动宽度布局</td>
</tr>
</tbody></table>
<h2 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h2><p>多栏布局类似于报纸文章的排版，可以将子元素自动划分为多列显示。</p>
<h3 id="列的数量"><a href="#列的数量" class="headerlink" title="列的数量"></a>列的数量</h3><p>使用<code>column-count</code>设置列的数量，并且将元素设置为多列布局容器。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>块级元素</td>
<td>不可继承</td>
<td><code>auto</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code></td>
<td>由<code>column-width</code>来决定</td>
</tr>
<tr>
<td>整数值</td>
<td>表示列的数量</td>
</tr>
</tbody></table>
<h3 id="列宽"><a href="#列宽" class="headerlink" title="列宽"></a>列宽</h3><p>使用<code>column-width</code>设置列的<strong>最小</strong>宽度，并且将元素设置为多列布局容器。注意，该属性与<code>column-count</code>可能会产生矛盾，最好不要同时设置。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>块级元素</td>
<td>不可继承</td>
<td><code>auto</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code></td>
<td>由<code>column-count</code>来决定</td>
</tr>
<tr>
<td>长度值</td>
<td>表示列的最小宽度</td>
</tr>
</tbody></table>
<h3 id="列间距"><a href="#列间距" class="headerlink" title="列间距"></a>列间距</h3><p>使用<code>column-gap</code>设置列的间距。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>多列布局容器</td>
<td>不可继承</td>
<td><code>normal</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>normal</code></td>
<td>相当于<code>1em</code></td>
</tr>
<tr>
<td>长度值</td>
<td>设置具体的列间距</td>
</tr>
</tbody></table>
<p><img src="https://ae01.alicdn.com/kf/H5f5aaa27c78e470fa8f4f427ec1a4642T.jpg" alt=""></p>
<h3 id="列分隔线"><a href="#列分隔线" class="headerlink" title="列分隔线"></a>列分隔线</h3><p>使用<code>column-rule</code>设置列间隙上的分隔线。该属性是<code>column-rule-width</code>、<code>column-rule-style</code>和<code>column-rule-color</code>三个属性的简写属性，顺序没有要求。它的用法与边框基本一致，不再赘述。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>多列布局容器</td>
<td>不可继承</td>
<td><code>normal</code></td>
</tr>
</tbody></table>
<pre><code class="css">.container {
    column-rule: 5px solid orange;
}</code></pre>
<p><img src="https://ae01.alicdn.com/kf/H0e86a6389dbf43089155444522b7b2f3h.jpg" alt=""></p>
<h3 id="内容分割"><a href="#内容分割" class="headerlink" title="内容分割"></a>内容分割</h3><p>使用<code>break-inside</code>阻止内容被截断。</p>
<table>
<thead>
<tr>
<th>适用于</th>
<th>继承性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>多列布局容器的<strong>内部元素</strong></td>
<td>不可继承</td>
<td><code>auto</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>可选值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>auto</code></td>
<td>可能会将一块内容截断到下一列，以调整合适的高度</td>
</tr>
<tr>
<td><code>avoid</code></td>
<td>不截断元素</td>
</tr>
</tbody></table>
<pre><code class="css">.container &gt; div {
    break-inside: avoid;
}</code></pre>
<p><img src="https://ae01.alicdn.com/kf/H83697a3d65854532b5617c913fe4b4e2c.jpg" alt=""></p>
</div>
    </div>
</div>

<div class="toc"></div>
    <footer>
    <p>© 2020</p>
    <p>Theme chicken by 小鸡米花, Powered by Hexo</p>
</footer>
    <a class="back-to-top" href="javascript:;"></a>

    <script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script>
    <script defer src="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.js"></script>
    <script defer src="https://cdn.staticfile.org/KaTeX/0.11.1/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, { strict: false, delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}] });"></script>
    <script src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js"></script>
    <script src="https://cdn.staticfile.org/highlight.js/9.18.1/highlight.min.js"></script>

    <script>
        // 为标签追加字体图标
        $('.tag-list-item').prepend('<span class="iconfont icon-biaoqian"></span>')

        // 回到顶部的猫
        $('.back-to-top').click(function () {
            $('html, body').animate({
                scrollTop: 0
            }, 500)
        })

        // 监听 回到顶部的猫 是否显示
        $(document).scroll(function () {
            if ($(document).scrollTop() > 50) {
                $('.back-to-top').addClass('show')
            } else {
                $('.back-to-top').removeClass('show')
            }
        })

        // 在表格外包裹一层，用来生成滚动条
        $('.post-content > table').wrap('<div class="table-container"></div>')

        // Tocbot 实例化，用来快速生成文档目录
        tocbot.init({
            tocSelector: '.toc', // 渲染目录的容器
            contentSelector: '.post-content', // 标题所在的容器
            headingSelector: 'h2, h3', // 要渲染的目录层级,
            headingsOffset: -50, // 微调目录高亮的显示位置（偏移量），防止点击的链接和高亮的链接不一致
        })

        // 初始化代码高亮 highlight.js
        hljs.initHighlightingOnLoad()

        // 自动加载 waifu
        try {
            $("<link>").attr({ href: "//cdn.yesuanzao.cn/blog/live2d/waifu.min.css", rel: "stylesheet", type: "text/css" }).appendTo('head');
            $('body').append('<div class="waifu"><div class="waifu-tips"></div><canvas id="live2d" class="live2d"></canvas><div class="waifu-tool"><span class="fui-home"></span> <span class="fui-chat"></span> <span class="fui-eye"></span> <span class="fui-user"></span> <span class="fui-photo"></span> <span class="fui-info-circle"></span> <span class="fui-cross"></span></div></div>');
            $.ajax({ url: '//cdn.yesuanzao.cn/blog/live2d/waifu-tips.js', dataType: "script", cache: true, async: false });
            $.ajax({ url: '//cdn.yesuanzao.cn/blog/live2d/live2d.min.js', dataType: "script", cache: true, async: false, complete: function() {
                initModel('//cdn.yesuanzao.cn/blog/live2d/waifu-tips.json');
            } });
        } catch (err) { console.log(err) }
    </script>
    <!-- 
        添加控制台，测试移动端
        <script src="http://cdn.jsdelivr.net/npm/eruda"></script>
        <script>eruda.init();</script>
    -->
</body>

</html>